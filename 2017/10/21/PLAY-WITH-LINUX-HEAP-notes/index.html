<!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.3"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.3"><link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222"><meta name="keywords" content="PWN,HEAP,"><link rel="alternate" href="/atom.xml" title="Flier's Blog" type="application/atom+xml"><meta name="description" content="PLAY WITH LINUX HEAP作者:memeda@0opspwner.xu@gamil.con BACKGROUND Linux heap become hard to exploit due to the new version of GLIBC. Hundreds of thousands of assertions there. ASLR and Non-eXecutable he"><meta name="keywords" content="PWN,HEAP"><meta property="og:type" content="article"><meta property="og:title" content="PLAY_WITH_LINUX_HEAP-notes"><meta property="og:url" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/index.html"><meta property="og:site_name" content="Flier&#39;s Blog"><meta property="og:description" content="PLAY WITH LINUX HEAP作者:memeda@0opspwner.xu@gamil.con BACKGROUND Linux heap become hard to exploit due to the new version of GLIBC. Hundreds of thousands of assertions there. ASLR and Non-eXecutable he"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/1.png"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/2.png"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/3.png"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/4.png"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/5.png"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/6.png"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/23247812.png"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/24518812.png"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/26908750.png"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/26971281.png"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/27513921.png"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/28013312.png"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/2992875.png"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/49546531.png"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/49736265.png"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/35814781.png"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/1148359.png"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/922812.png"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/1327031.png"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/1576000.png"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/2574921.png"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/3975375.png"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/4391250.png"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/4549625.png"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/4646984.png"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/4814390.png"><meta property="og:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/4828218.png"><meta property="og:updated_time" content="2017-10-21T05:05:53.038Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="PLAY_WITH_LINUX_HEAP-notes"><meta name="twitter:description" content="PLAY WITH LINUX HEAP作者:memeda@0opspwner.xu@gamil.con BACKGROUND Linux heap become hard to exploit due to the new version of GLIBC. Hundreds of thousands of assertions there. ASLR and Non-eXecutable he"><meta name="twitter:image" content="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/1.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"5.1.3",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/"><title>PLAY_WITH_LINUX_HEAP-notes | Flier's Blog</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Flier's Blog</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">F1r</h1></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i><br> 站点地图</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="F1r"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Flier's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">PLAY_WITH_LINUX_HEAP-notes</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-21T11:42:24+08:00">2017-10-21</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/PWN/" itemprop="url" rel="index"><span itemprop="name">PWN</span></a></span></span> <span class="post-comments-count"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span><a href="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/10/21/PLAY-WITH-LINUX-HEAP-notes/" itemprop="commentCount"></span></a></span> <span class="post-meta-divider">|</span> <span class="page-pv">本文总阅读量<span class="busuanzi-value" id="busuanzi_value_page_pv"></span> 次</span></div></header><div class="post-body" itemprop="articleBody"><h1 id="PLAY-WITH-LINUX-HEAP"><a href="#PLAY-WITH-LINUX-HEAP" class="headerlink" title="PLAY WITH LINUX HEAP"></a>PLAY WITH LINUX HEAP</h1><p>作者:<br><strong>memeda@0ops</strong><br><strong>pwner.xu@gamil.con</strong></p><h2 id="BACKGROUND"><a href="#BACKGROUND" class="headerlink" title="BACKGROUND"></a>BACKGROUND</h2><ol><li>Linux heap become hard to exploit due to the new version of GLIBC.<ul><li>Hundreds of thousands of assertions there.</li><li>ASLR and Non-eXecutable heap.</li></ul></li><li>Heap issues are scarce in CTF games.<ul><li>spring up in recent games like HOTCON CTF &amp; Hack.LU CTF.</li></ul></li></ol><h2 id="CATALOGUE"><a href="#CATALOGUE" class="headerlink" title="CATALOGUE"></a>CATALOGUE</h2><ol><li>Introduction to GLIBC Heap</li><li>View Heap As an Attacker<ul><li>free()</li><li>malloc()</li><li>main_arena</li><li>mmap() &amp; munmap()</li></ul></li><li>Examples</li></ol><a id="more"></a><h2 id="Introduction-to-GLIBC-Heap"><a href="#Introduction-to-GLIBC-Heap" class="headerlink" title="Introduction to GLIBC Heap"></a>Introduction to GLIBC Heap</h2><h3 id="GLIBC-Heap-Structure"><a href="#GLIBC-Heap-Structure" class="headerlink" title="GLIBC Heap Structure"></a>GLIBC Heap Structure</h3><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/1.png" alt=""></p><blockquote><p>chunk头包括以下两部分：<br>prev_size: 如果当前chunk的相邻前一chunk未被使用，prev_size为此前一chunk的大小<br>size: 当前chunk的大小。由于chunk大小是8的整数倍，所以此size的后3 bit被用于存储其他信息。我们需要记住的便是最低bit，用于指示前一chunk是否已被使用( <strong>PREV_INUSE</strong> )。<br>如果当前chunk处于未被使用状态，则mem前8 bytes被用来存储其他信息，具体如下：<br>fd: 下一个未被使用的chunk的地址<br>bk: 上一个未被使用的chunk的地址<br>可以看到，chunk头中包含的大小信息，主要用来在获取内存中相邻chunk的地址（当前chunk地址减去前一chunk的大小，为前一chunk的地址；当前chunk地址加上当前chunk的大小，为后一chunk的地址）。而mem中的fd和bk只在当前chunk处于未被使用时才有意义。如果了解数据结构，便可以立刻看出，这些未被使用的chunks通过fd, bk组成了链表。事实上，malloc确实维护了一系列链表用于内存的分配和回收，这些链表被成为”bins”。<br>一般来说，每个bin链表中的chunk都有相同或将近的大小。根据bin所包含chunk的大小，可以将bin分为fastbin, unsorted bin, small bin, large bin。</p></blockquote><ul><li>the range of a chunk is between LABEL Chunk and LABEL Next Chunk</li><li>PREV_SIZE represents the size of the previous chunk(in memory) only if the previos chunk is <strong>free()’d</strong>.</li><li>SIZE represents the number of bytes between LABEL Chunk and LABEL Next Chunk. <font color="red"><strong>If the lowest bit of SIZE is cleared as 0, then the chunk before it is not in use(free)</strong>.</font></li><li>LABEL Mem makes sense only when this chunk is <strong>malloc()’d</strong> by user. &amp;Mem is considered as the return value of <strong>malloc()</strong>.</li><li>For chunks of certain size range, there is a <strong>free list</strong> which is a linked list.</li><li>FD represents the forward pointer to the next chunk in the linked list.</li><li>BK represents the backward pointer to the previous chunk in the linked list.</li><li>The above two fields only make sense when the chunk is <strong>free()’d</strong></li><li>User’s data is stored in the region which starts at LABEL Mem. Notice that the region includes PREV_SIZE of the next chunk.</li></ul><h2 id="View-Heap-as-an-Attacker-—-free"><a href="#View-Heap-as-an-Attacker-—-free" class="headerlink" title="View Heap as an Attacker — free()"></a>View Heap as an Attacker — free()</h2><h3 id="CORRUPT-FREE-1"><a href="#CORRUPT-FREE-1" class="headerlink" title="CORRUPT FREE 1"></a>CORRUPT FREE 1</h3><ul><li>Let’s begin at function <strong>free()</strong> but not <strong>malloc()</strong>.</li><li>In the old version of GLIBC, there is a classical exploition of heap overflow with <strong>free()</strong>.</li></ul><h3 id="PROTOSTAR-HEAP-3"><a href="#PROTOSTAR-HEAP-3" class="headerlink" title="PROTOSTAR HEAP 3"></a>PROTOSTAR HEAP 3</h3><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/2.png" alt=""></p><ul><li>In old version of GLIBC malloc, there is function called unlink():</li></ul><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/3.png" alt=""></p><ul><li>If BK and FD is controlled by us, then (in Linux x86)<ul><li>*(FD + 12) = BK &amp;&amp; *(BK + 8) = FD</li><li><strong>AN ARBITRARY WRITE!</strong></li></ul></li><li>Then the problem comes, why <strong>unlink()</strong> is called when <strong>3 free()</strong>s called? Since <strong>free()</strong> means linking the chunk into the <strong>free list</strong>.</li><li><font color="red">THE ANSWER is when GLIBC free a chunk, it will go to see whether the chunk before/after is free. If it is, then <strong>the chunk before/after will be unlink()’d off its double-linked list</strong> and these two chunks merge into one chunk.</font></li><li>So for this problem, you can overflow chunk a and overwrite the <strong>heap header</strong> of chunk b.</li><li><em>If you <font color="red">set the lowest bit of SIZE of b to 0, then GLIBC fooled to consider chunk a free()’d. Then <strong>unlink()</strong> is called on chunk a</font>.</em></li></ul><blockquote><p>SIZE represents the number of bytes between LABEL Chunk and LABEL Next Chunk. <strong>If the lowest bit of SIZE is cleared as 0, then the chunk before it is not in use(free).</strong></p></blockquote><ul><li>You can also set <strong>PREV_SIZE f chunk b</strong> to fool GLIBC where the chunk b begins. Craft a fake chunk b there and get an arbitrary wirte.</li></ul><h3 id="MODERN-UNLINK"><a href="#MODERN-UNLINK" class="headerlink" title="MODERN UNLINK"></a>MODERN UNLINK</h3><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/4.png" alt=""></p><p><strong>New checking: FD-&gt;bk \== P &amp;&amp; BK-&gt;fd \== P</strong></p><h3 id="CORRUPT-FREE-2"><a href="#CORRUPT-FREE-2" class="headerlink" title="CORRUPT FREE 2"></a>CORRUPT FREE 2</h3><ul><li>Let us have a look at Problem stkof from HITCON CTF 2014.</li><li>Pwnable worth 550 points. It is still available on httpL//ctf2014.hitcon.org/dashboard.html.</li><li>The scenario is simple:<ul><li>You can give a size and malloc a chunk of the size.</li><li>There is global arrary which records the pointer of every chunk you malloc()’d.</li><li>You can write arbitrary long content into the pointer in the global array.</li><li>You can free any of the chunk you malloc()’d before.</li><li>There is a global variable record the times you malloc()’d.</li></ul></li></ul><h3 id="PWNABLE-PROBLEM-STKOF"><a href="#PWNABLE-PROBLEM-STKOF" class="headerlink" title="PWNABLE PROBLEM STKOF"></a>PWNABLE PROBLEM STKOF</h3><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/5.png" alt=""></p><p>In this scenario, there is a variable counting how much chunk you’ve malloc()’d. Here it is 3 at 0x602100.</p><ul><li>3 chunk’s pointer are stored in a global arrary at 0x602140, which is 0xe05010, 0xe05040 and 0xe050d0(Remember is is what we called LABEL Mem).</li><li>We can also writing anything long into the data area these pointers pointing to.</li></ul><h3 id="CORRUPT-FREE-2-1"><a href="#CORRUPT-FREE-2-1" class="headerlink" title="CORRUPT FREE 2"></a>CORRUPT FREE 2</h3><ul><li>Heap Overflow with free()’ called, everything is nice except that<ul><li>FD-&gt;bk ?= P</li><li>BK-&gt;fd ?= P</li></ul></li><li>When facing this, the MOST IMPORTANT thing is that <font color="red"><strong>find somewhere in the memory in which the value is P</strong></font>.</li></ul><blockquote><p>PS: Geohot’s futex exploit trick(0x00bf0000) to bypass plist checking in <em>Android Kernel</em>.</p></blockquote><ul><li>In this problem, there is a global arrary which stores all the pointer pointing to all the chunk. Notice that this pointer is pointing to LABEL &amp;Mem but not that start of the chunk!</li><li>So we need to craft a fake chunk at &amp;Mem. That is not very difficult because we have heap overflow whcih means the whole control of the content of the chunk on the heap.</li><li>Another restriction shown in the code before is the <em>if</em> clause.<ul><li>Just set P-&gt;fd_nextsize to NULL then skip if.</li></ul></li><li>EXP from acez@Shellphish</li></ul><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/6.png" alt=""></p><p><a href="http://" target="_blank" rel="external">http://github.com/acama/ctf-writeups/blob/master/hitcon2014/stkof/x.py</a></p><ul><li>As you can see, the exploit overwrite chunk 3, place a fake chunk at the location of chunk 4.</li><li>The fake heap header of chunk 4 fool GLIBC to believe that chunk before chunk 4 is chunk 2.</li><li>There is a fake chunk 2 at chunk 2’Mem. Notice that 0x602150 is the pointer in the global array which pointing to chunk 2’s Mem(<strong>key point here to bypass the chunk!</strong>).</li><li><font color="red">Call free(4) to unlink fake chunk2. Then after unlink, an address in the range of &amp;global_arrary itself is written into the global arrary. That means we can rewrite the content of the global arrary directly.</font></li><li>If we control the global array, then wen can control which pointer we can write into.</li><li>This is a case about heap overflow where <strong>SPECIFIC WRITE</strong> turns into <strong>ARBITRARY WRITE</strong>！</li></ul><h3 id="Always-keep-in-mind"><a href="#Always-keep-in-mind" class="headerlink" title=" Always keep in mind "></a> <font color="red">Always keep in mind</font></h3><ul><li>When malloc() returns, it gives you the pointer pointing to LABEL Mem.</li><li>When processing some stuff in malloc.c, the pointer of a chunk(whose type is <font color="red"><strong>struct malloc_chunk *</strong></font> ) is pointing to LABEL Chunk.</li></ul><h3 id="POISINED-NULL-BYTE"><a href="#POISINED-NULL-BYTE" class="headerlink" title="POISINED NULL BYTE"></a>POISINED NULL BYTE</h3><ul><li>In August Zero released a post about a GLIBC NULL byte off-by-one exploitation.</li><li>The null byte will clear all the status bits of the SIZE of the next chunk.<ul><li>The <font color="red">PREV_SIZE</font> is actually the user data of the chunk but now it will used to locate the chunk</li></ul></li><li>The exploit decribed in the post is a local unprivilrge exploit with Linux 32bit, which means we could half-disable ASLR and things become easy.</li></ul><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/23247812.png" alt=""></p><p>The exploit regerred in the post used <font color="red">fd\nextsize</font> and <font color="red">bk-nextsize</font> to do the arbitrary write which is also a way besides directly use <font color="red">fd</font> and <font color="red">bk</font>.</p><ol><li><font color="red">P-&gt;fd_nextsize</font> should not be NULL.</li><li><font color="red">FD-&gt;fd_nextsize</font> should not be NULL.</li></ol><p>However, the target in the post is Fedora where that two aserts do not exist. When it comes to Ubuntu, Fail.</p><h2 id="View-Heap-as-an-Attacker-—-malloc"><a href="#View-Heap-as-an-Attacker-—-malloc" class="headerlink" title="View Heap as an Attacker — malloc()"></a>View Heap as an Attacker — malloc()</h2><h3 id="CHEAT-MALLOC-1"><a href="#CHEAT-MALLOC-1" class="headerlink" title="CHEAT MALLOC 1"></a>CHEAT MALLOC 1</h3><ul><li>free()’d chunks which has a size in certain range will be put into one free list.</li><li>The head of the free list is in main_arena which will be covered later.</li><li>The basic idea of the section is to <font color="red">CHEAT</font> GLIBC to malloc the chunk to the special place you want to. Then you can write to that heap chunk, which means that you write to that special place.</li><li>If there are some important pointers or data structures at that special place, then it is easy to finish the exploit then.</li></ul><h4 id="begin-with-an-easy-example-–-fastbin"><a href="#begin-with-an-easy-example-–-fastbin" class="headerlink" title="begin with an easy example – fastbin"></a>begin with an easy example – fastbin</h4><ul><li>When the chunk’s size is small enough, GLIBC called it fastbin.</li><li>Different sizes of fastbins also have their free list, but this time it is a <font color="red">single-linked list</font>.</li><li>The single-linked list makes things much easier.</li></ul><p>This picture shows two fastbins in the free list which both have a size of 0x30.<img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/24518812.png" alt=""></p><p>Single-linked list header 0x7fff7bd1770 pointing to Chunk 0x00e05090.<br>Chunk 0x00e05090’s FD pointing to Chunk 0x00e05030.<br>Chunk 0x00e05030’s FD is NULL, the end of this linked list.</p><h4 id="How-does-GLIBC-work-when-malloc-ing-a-fastbin"><a href="#How-does-GLIBC-work-when-malloc-ing-a-fastbin" class="headerlink" title="How does GLIBC work when malloc()ing a fastbin?"></a>How does GLIBC work when malloc()ing a fastbin?</h4><ul><li>It just mainly pick out <font color="red">the first</font> (-&gt;fd) fastbin in the linked list, and return it to the user.</li><li><p>That meas if we <font color="red">control just one node of this linked list</font>, then we can cheat GLIBC to malloc the chunk where specified by us.</p></li><li><p>maclloc two fastbins.</p><ol><li>Free the 2nd fastbin.</li><li>Overflow the 1st fastbin to change 2nd fastbin’s FD to our specified value.</li><li>Malloc one time. GLIBC return the 2nd fastbin to us, meanwhile the header of the single-linked list points to our specified value. The value points to a fake fastbin entry we crafted already.</li><li>Malloc anather time.</li><li>Then just write into the new chunk which birth at the specified place you want to and finish your exploit.</li></ol></li><li><p>EASY to exploit since single-linked list is less troublesome, comparing with double-linked list with countless security check with normal bins in the new version of GLIBC malloc.c.</p></li><li><p>The only check for the fastbin entr in the list is the <font color="red">SIZE</font>! Craft a proper size for the fake fastbin entry.</p><ul><li>Recall the problem STKOF, where the fakebin could be?</li><li>There is a counting variable at 0x602100, just add it up to a proper value and it somehow could pretend to be <font color="red">SIZE</font> right?(the fake chunk at 0x602100 - 0x8)</li></ul></li><li><p>If you can free any where you want, then just free the place you could write(craft) directly. You don’t necessarily need to work on the heap and do the overflow.</p></li><li>Or if you can overwrite the malloc()’d pointer to a specia=fy value and then free it, also take the same effect.<ul><li>This scenario is mentioned in phrack Malloc_Des-Maleficarum.</li></ul></li></ul><h3 id="CHEAT-MALLOC-2"><a href="#CHEAT-MALLOC-2" class="headerlink" title="CHEAT MALLOC 2"></a>CHEAT MALLOC 2</h3><h4 id="Whether-malloc-with-normal-bins-and-double-linked-can-be-cheated"><a href="#Whether-malloc-with-normal-bins-and-double-linked-can-be-cheated" class="headerlink" title="Whether malloc() with normal bins and double-linked can be cheated"></a>Whether malloc() with normal bins and double-linked can be cheated</h4><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/26908750.png" alt=""></p><p>I malloc 7 chunks with normal size and free 3 of them. As you can see, they are both in one double-linked list.</p><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/26971281.png" alt=""></p><p>Then I do malloc(0x212).</p><ul><li>As you can see, strange things happen. Now two double-linked lists there.</li><li>In fact, double-linked list(0x7ffff7bd17b8) is called the <font color="red">unsorted bin’s free list</font>.</li><li><p>double-linked list(0x7ffff7bd19b8) is the real list for the real free list for the chunk with size 0x210.</p></li><li><p>At first, all the free()’d chunks are put in to unsorted bin list.</p></li><li>When alloc() comes, GLIBC travels from the BK of the header of the unsortd bin list.<ul><li>If the size is fit, then unlink this chunk and return to the user.</li><li>If not, put this chunk into its free list according to its size.</li></ul></li><li>I am going to give an illustration about exploiting this.</li></ul><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/27513921.png" alt=""></p><p>Overflow Chunk 0xe05210 to change 0xe05630’s BK to an address which points to a craft heap chunk. The chunk has a right SIZE(0x211).]</p><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/28013312.png" alt=""></p><p>As you can see, after I malloc(0x212), the header of the unsort bin list’s BK points to my fake chunk at 0xe10000.</p><ul><li>A very important thing is that during the process shown before, there is <font color="red">NO CHECKING like P-&gt;FD-&gt;BK == P AND so on</font>.</li><li>And after this, you are able to cheat GLIBC to malloc at the place you want(int this case 0xe10000). But during this, Chunk 0xe10000 will be unlinked so make sure its BK-&gt;FD points to 0xe10000 this time.</li><li>For this case, I just bring out my ideas. Let me know if you have other nice ways to exploit it.</li></ul><h3 id="CHEAT-MALLOC-3"><a href="#CHEAT-MALLOC-3" class="headerlink" title="CHEAT MALLOC 3"></a>CHEAT MALLOC 3</h3><ul><li>There is another important concept called <font color="red"><strong>wilderness</strong></font> or the <font color="red">top</font> chunk.</li><li>In a word, if there is no proper chunk in the free list, then GLIBC will splice a certain size out of the top chunk and then return it to ther user.</li><li><p>That means the top chunk usually has a large <font color="red">SIZE</font> and be located at the bottom of the heap (behind all the normal heao chunks).</p></li><li><p>Malloc_DES-Maleficarum also described a trick which cheats malloc by using <font color="red">the top chunk</font>.</p><ol><li>You can use overflow to change the <font color="red">SIZE</font> of the top chunk to 0xffffffff(Linux x86).</li><li>Then you just malloc, and if the control flow goes into <font color="red">use_top</font>, then actually you can malloc whatever large size you want.</li><li>You can craft a special size <font color="red">s</font>. Then after malloc()ing, the top chunk’s address will change to the original address plus <font color="red">s</font>. In fact, we can specify any new address we want by specifying <font color="red">s</font>.</li><li>If we malloc again, then we could get a chunk at the special place we want.</li></ol></li><li>This trick may not make sense when meet <font color="red">ASLR</font> since at most time the location of the top chunk cannot be predicted.</li></ul><h2 id="View-Heap-as-an-Attacker-—-main-arena-predict-heap-chunk’s-location-despite-ASLR"><a href="#View-Heap-as-an-Attacker-—-main-arena-predict-heap-chunk’s-location-despite-ASLR" class="headerlink" title="View Heap as an Attacker — main_arena / predict heap chunk’s location despite ASLR"></a>View Heap as an Attacker — main_arena / predict heap chunk’s location despite ASLR</h2><h3 id="MAIN-ARENA"><a href="#MAIN-ARENA" class="headerlink" title="MAIN_ARENA"></a>MAIN_ARENA</h3><ul><li>It’s time for us back to the most basic and important structure <font color="red"><strong>main_arena</strong></font>.</li><li><p>Hack the <font color="red"><strong>core</strong></font> then we control all.</p></li><li><p>main_arena is defined as below(Linux x86_64)</p></li></ul><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/2992875.png" alt=""></p><ul><li><p>It is a structure of type malloc_state and size is 0x888.</p></li><li><p>Array fastbinY</p><ul><li>The Value in each entry represents the head of (single-linked) free list of the fastbins whcih has a size in certain range.</li></ul></li><li>Top<ul><li>It is the top-most chunk. When there is no good target chunk for a new malloc request in these free lists, it is used.(label use_top in function _int_malloc)</li></ul></li><li>Array bins<ul><li>Heads of all the (double-linked) free list of different size ranges.</li></ul></li><li>next<br> Pointing to the next arena.</li><li>system_mem<br> Memory allocated from the system in this arena.</li></ul><h4 id="FAKE-MAIN-ARENA"><a href="#FAKE-MAIN-ARENA" class="headerlink" title="FAKE MAIN_ARENA"></a>FAKE MAIN_ARENA</h4><ul><li>A <font color="red">POINTER</font> pointing to arena structure is near <font color="red">TLS</font>.<ul><li>How to use heap overflow to rewrite it? I’ll talk about it later.</li></ul></li><li><p>Now, let us have a discussion on how to do an exploitation when we could specify the arena which we can fully controlled.</p></li><li><p>The main idea is to specify the head of the linked list in the arena, and then cheat GLIBC to malloc a new chunk at that specified place we prefer.</p></li><li>But thing are not very easy. The specified place(the fake chunk) must satisfy many conditions, otherwise <em>malloc</em> will go to failure.</li></ul><h4 id="FIGHTING-WITH-ASSERTIONS"><a href="#FIGHTING-WITH-ASSERTIONS" class="headerlink" title="FIGHTING WITH ASSERTIONS"></a>FIGHTING WITH ASSERTIONS</h4><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/49546531.png" alt=""></p><ul><li>Let us trace back the source.</li><li>Before <em>_libc_malloc</em> exit, there is an assert on victim, the chunk which is going to return to you.<ol><li>If victim == NULL, just don’t care this</li><li>If the chunk is labelled <em>mmapped</em><ul><li>a chunk is mmapped when its <strong>SIZE</strong> has 0x2 bit set.</li></ul></li><li>If ar_ptr == victim’s arena ptr<ul><li>Due to the faked arena we crafted, chunk_non_main_arena will return true.<ul><li>If the <font color="red">SIZE</font> has 0x4 bit set, it means NON_MAIN_ARENA.</li></ul></li><li>And it is very hard to control the value which address <em>(ptr &amp; ~(HEAP_MAX_SIZE - 1))</em> pointing to.<ul><li>It is very hard to control on Linux x86_64. If ptr is not big enough, it will cause NULL pointer dereference.</li></ul></li></ul></li></ol><ul><li>So in a word, the best choice is to satisfy <font color="red">[2]</font> and then bypass this assert.<br><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/49736265.png" alt=""></li></ul></li></ul><blockquote><p>BTW</p><ul><li>Actually when we call free(p), it weill call arena_for_chunk(p) to get the arena of the chunk.</li><li>What if we use heap overflow to set a chunk’s NON_MAIN_ARENA bit?<ul><li>it will then try (ptr &amp; ~(HEAP_MAX_SIZE - 1))-&gt;ar_ptr to get the arena pointer…</li><li>That may cause problems, which is mentioned in phrack Malloc_Des-Maleficarum.</li></ul></li></ul></blockquote><ul><li>To satisfy <font color="red">[2]</font>, you faked chunk’s <font color="red">SIZE</font> should have 0x2 bit (<em>mmapped</em>).</li><li>If you deep into _int_malloc, you will find out that sometimes before it return p; to exit, it will finally <font color="red">reset the head of the chunk</font> which it will then return to you, which means you’ll lose the 0x2 bit.</li><li><p>We do not hope that happeds.</p></li><li><p><font color="red">3 scenarios where the head of our crafted chunk wont’t be reset</font></p><ul><li>fastbin size range;</li><li>corresponding small bin’s free list is not empty;</li><li>a free()’d candidate chunk in unsort bin free list and the size of free()’d candidate chunk in the free list is exactly the same as our crafted chunk’s size.</li></ul></li><li><p>Again,<font color="red">fastbin</font> becomes our first choice, since we must deal witg FD and BK when use whether normal small bin or normal large bin.</p></li><li>[1] A crafted chunk you want to malloc on which has a proper <font color="red">SIZE</font>(0x2 bit set).<ul><li>Remember an non-NULL illegal FD of this chunk will not make a crash during this malloc() but will bring a side effect in the furture.</li><li>[2] The entry of fastbinY’s free list should be set to the address of your crafted chunk.(&amp;<font color="red">SIZE</font> - 0x8 on Linux x86_64).</li></ul></li></ul><h4 id="A-FAKE-ARENA-EXAMPLE"><a href="#A-FAKE-ARENA-EXAMPLE" class="headerlink" title="A FAKE ARENA EXAMPLE"></a>A FAKE ARENA EXAMPLE</h4><p>you do not need to specify the whole 0x888 bytes. For example, if you use fast bin to exploit, you may must specify the first several bytes.</p><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/35814781.png" alt=""></p><h3 id="DEFEAT-ASLR"><a href="#DEFEAT-ASLR" class="headerlink" title="DEFEAT ASLR"></a>DEFEAT ASLR</h3><ul><li>Where is the problem of main_arena? How could we touch it?</li><li>If the size you want to malloc is not less than 128KB, then GLIBC may use <em>mmap()</em> to allocate a new area for you.</li><li>There are many gaps in the program’s VM map, and GLIBC will use these large gaps to satisfy your malloc request.</li></ul><p>main_arena is in the marked area(TLS is there), and if we can malloc a chunk before this arena nad overflow it, then we can overwrite main_arena.</p><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/1148359.png" alt=""></p><ul><li>Although the existence of ASLR, I would like to say that it is possible to know it is possible to know it is the time I malloc()’d just before TLS.</li><li><p>In fact, the location of the chunk you malloc()’d could be predicted even on Linux x86_64.</p></li><li><p>Consider a program(stkof) which doesn’t have any chunk malloc90d before the user’s input comes.</p></li><li>[1] Then I try to malloc(2147483648) as many times as possible.</li><li>[2] And then I malloc(135168).<em>The chunk will be located just before TLS. I will fill it with As to give an illustration.</em></li><li>Note that all the malloc()s in [1] &amp; [2] will actually call <em>mmap()</em>.</li></ul><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/922812.png" alt=""></p><p>The chunk just before arena is located at 0x7f0313248010. And with no surprise, the pointer of arena is at 0x7f031326a700. So, it is able to overflow it for sure. Btw, the stack canary is at 0x7f031326a768.</p><ul><li>Before the pointer of the arena, there are some values.</li><li>Actually most of these values can just be overwritten to 0x0 except the first entry(which is located at 0x7f031326a690 in the previous picture).<ul><li>Its symbol is _nl_global_lacale.</li><li>And is used in ____strtoll_I_internal.</li></ul></li></ul><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/1327031.png" alt=""></p><p>We should put an accessible pointer for a fake _nl_global_locale. And think it as %r8, make sure that these will not cause a segmentation fault:</p><ul><li>mov 0x8(%r8), % rax</li><li>mov 0x68(%r8), %r15</li><li>testb $0x20, 0x1 (%r15, %rax, 2)<ul><li>Here %rax usually range from ord(‘0’) to ord(‘9’)</li></ul></li></ul><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/1576000.png" alt=""></p><ul><li>OK! Now just replace the pointer of the <strong>arena</strong> with an address which a fake arena structure is located at there.</li><li>BUT! Due to ASLR, you may not know the exact address of your fake arena structure……</li></ul><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/2574921.png" alt=""></p><p>Actually there are two gaps and the location of the two gaps are easy to predicted.</p><ul><li>When I malloc() for hundreds of thousands of times, the process will try its best to bring out its virtual memory to satisfy my demand.</li><li>And finally the chunk will be located between 0x10000 - 0x400000 and 0x401000 - 0x601010.</li><li>AS you can see, I get two chunk, one is at 0x10000 and one is at 0x4010000.</li><li> <font color="red">You can just put the fake arena and the fake _nl_global_locale in the 0x10000 chunk and then overwrite the pointer of the arena to 0x10010 (0x10000 + 0x10 is the beginning of the user data).</font></li></ul><h3 id="FURTHERMORE"><a href="#FURTHERMORE" class="headerlink" title="FURTHERMORE"></a>FURTHERMORE</h3><ul><li>The main_arena exploit on x86 is much more easier so I do not mention here.</li><li>A writeup from 217 refers this:</li><li><a href="http://217.logdown.com/posts/241446-isg-2014-pepper" target="_blank" rel="external">http://217.logdown.com/posts/241446-isg-2014-pepper</a></li></ul><h2 id="View-Heap-as-an-Attacker-–-mmap-and-munmap"><a href="#View-Heap-as-an-Attacker-–-mmap-and-munmap" class="headerlink" title="View Heap as an Attacker – mmap() and munmap()"></a>View Heap as an Attacker – mmap() and munmap()</h2><h3 id="OWN-THE-PAGE"><a href="#OWN-THE-PAGE" class="headerlink" title="OWN THE PAGE"></a>OWN THE PAGE</h3><ul><li>A trick</li><li> <font color="red">Turn a <strong>r--</strong> page into <strong>rw-</strong> page without calling mprotect() or even unmap .text page</font>.</li><li><p>Special thanks to <strong>jerry@217</strong> for sharing this idea.</p></li><li><p>As is mentioned before, if a chunk’s <font color="red">SIZE</font> has 0x2 bit, it means this chunk is <strong>MMAPPED</strong>.</p></li><li><p>And if we want to free a MMAPPED chunk, GLIBC will not call free() routine for normal heap chunk but munmap()!</p></li><li><p>If you could overwrite the <strong>SIZE</strong> of a chunk, set its 0x2 bit and any large size you want, then free it!</p><ul><li><font color="red">The memory of the size will be directly kicked out!</font></li></ul></li></ul><ol><li>Malloc()’d for thousands of times to push GLIBC to <font color="red">malloc a chunk at 0x300000 and 0x200000</font>.</li><li>Overflow the chunk at <font color="red">0x200000</font> to make <font color="red">0x300000’s <strong>SIZE</strong></font> to 0x20000<font color="red">2</font>.</li><li><font color="red">0x400000 - 0x401000</font> is .text section of the process.</li></ol><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/3975375.png" alt=""></p><p>It is really interesting right? Memory from <font color="red">0x300000 to 0x500000</font> is munmap()’d by me. $rip is at <font color="red">0x400b7f</font> but it is an illegal address now!</p><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/4391250.png" alt=""></p><p><strong>GOT</strong> is in the marked page. We could allocate a chunk in <font color="red">0x401000-0x601000</font>, overflow it and rewrite <strong>GOT</strong>.</p><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/4549625.png" alt=""></p><p>The sad thing is that if we want to overwrite <strong>GOT</strong>, we must cross <font color="red">0x601000-0x602000</font>, but however this page is non-writable!</p><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/4646984.png" alt=""></p><ul><li>Use heaop heapoverflow to change the <font color="red">SIZE</font> of chunk to 0x10100<font color="red">2</font>. Then free it!</li></ul><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/4814390.png" alt=""></p><ul><li>With no surprise, memory from <font color="red">0x501000 to 0x602000</font> is kicked out.</li><li>That means the non-writable page has already gone away.</li></ul><p><img src="/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/4828218.png" alt=""></p><p>If we malloc(1052600), Non-writable page <font color="red">0x601000-0x602000</font> will never be existed. Just overflow it to write GOT!</p><ul><li>It is a very interesting trick about mmap() and munmap() in GLIBC heap menagement.</li><li>Keep in mind that the fake <font color="red"><strong>SIZE</strong></font> of the chunk you set must be times of a page size, due to <font color="red">ASSERT</font></li></ul><h2 id="RESOURCES"><a href="#RESOURCES" class="headerlink" title="RESOURCES"></a>RESOURCES</h2><p>STKOK <a href="https://github.com/hitcon2014ctf/ctf/raw/master/a679df07a8f3a8d590febad45336d031-stkof" target="_blank" rel="external">https://github.com/hitcon2014ctf/ctf/raw/master/a679df07a8f3a8d590febad45336d031-stkof</a></p><p>ORED <a href="https://github.com/lovelydream/CTF/blob/master/oreo_35f118d90a7790bbd1eb6d4549993ef0" target="_blank" rel="external">https://github.com/lovelydream/CTF/blob/master/oreo_35f118d90a7790bbd1eb6d4549993ef0</a></p><p>PEPPER <a href="https://github.com/lovelydream/CTF/blob/master/pepper_e87791048cc540b725046a96d6724d8b" target="_blank" rel="external">https://github.com/lovelydream/CTF/blob/master/pepper_e87791048cc540b725046a96d6724d8b</a></p><h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="http://conceptofproof.wordpress.com/2013/11/19/protostar-heap3-walkthrough/" target="_blank" rel="external">http://conceptofproof.wordpress.com/2013/11/19/protostar-heap3-walkthrough/</a></p><p><a href="http://acez.re/" target="_blank" rel="external">http://acez.re/</a></p><p><a href="https://rzhou.org/~ricky/hitcon2014/stkof/test.py" target="_blank" rel="external">https://rzhou.org/~ricky/hitcon2014/stkof/test.py</a></p><p><a href="https://www.blackhat.com/presentations/bh-usa-07/Ferguson/Whitepaper/bh-usa-07-ferguson-WP.pdf" target="_blank" rel="external">https://www.blackhat.com/presentations/bh-usa-07/Ferguson/Whitepaper/bh-usa-07-ferguson-WP.pdf</a></p><p><a href="http://217.logdown.com/posts/241446-isg-2014-pepper" target="_blank" rel="external">http://217.logdown.com/posts/241446-isg-2014-pepper</a></p><p><a href="http://googleprojectzero.blogspot.sg/2014/08/the-poisoned-nul-byte-2014-edition.html" target="_blank" rel="external">http://googleprojectzero.blogspot.sg/2014/08/the-poisoned-nul-byte-2014-edition.html</a></p><p><a href="http://sebug.net/paper/phrack/66/p66_0x0A_Malloc_Des-Maleficarum.txt" target="_blank" rel="external">http://sebug.net/paper/phrack/66/p66_0x0A_Malloc_Des-Maleficarum.txt</a></p><p><a href="http://www.phrack.org/issues/57/8.html" target="_blank" rel="external">http://www.phrack.org/issues/57/8.html</a></p></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/PWN/" rel="tag"># PWN</a> <a href="/tags/HEAP/" rel="tag"># HEAP</a></div><div class="post-widgets"><div id="needsharebutton-postbottom"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/10/19/karspersky-helpme/" rel="next" title="karspersky-helpme"><i class="fa fa-chevron-left"></i> karspersky-helpme</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/2017/10/24/Heap-Exploitation-base-knowledge-notes/" rel="prev" title="Heap-Exploitation-base-knowledge-notes">Heap-Exploitation-base-knowledge-notes<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"><script>with(document)(getElementsByTagName("head")[0]||body).appendChild(createElement("script")).src="//bdimg.share.baidu.com/static/api/js/share.js?cdnversion="+~(-new Date/36e5)</script></div></div></div><div class="comments" id="comments"><div id="disqus_thread"><noscript> Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">F1r</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">8</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">6</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/F1r" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:fliergoo@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-google"></i> E-Mail</a></span><span class="links-of-author-item"><a href="http://bestwing.me" target="_blank" title="Swing'Blog"><i class="fa fa-fw fa-globe"></i> Swing'Blog</a></span><span class="links-of-author-item"><a href="http://www.bendawang.site" target="_blank" title="Bendawang"><i class="fa fa-fw fa-globe"></i> Bendawang</a></span><span class="links-of-author-item"><a href="https://burnegg.com/" target="_blank" title="burnegg"><i class="fa fa-fw fa-globe"></i> burnegg</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#PLAY-WITH-LINUX-HEAP"><span class="nav-number">1.</span> <span class="nav-text">PLAY WITH LINUX HEAP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BACKGROUND"><span class="nav-number">1.1.</span> <span class="nav-text">BACKGROUND</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CATALOGUE"><span class="nav-number">1.2.</span> <span class="nav-text">CATALOGUE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction-to-GLIBC-Heap"><span class="nav-number">1.3.</span> <span class="nav-text">Introduction to GLIBC Heap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GLIBC-Heap-Structure"><span class="nav-number">1.3.1.</span> <span class="nav-text">GLIBC Heap Structure</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View-Heap-as-an-Attacker-—-free"><span class="nav-number">1.4.</span> <span class="nav-text">View Heap as an Attacker — free()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CORRUPT-FREE-1"><span class="nav-number">1.4.1.</span> <span class="nav-text">CORRUPT FREE 1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PROTOSTAR-HEAP-3"><span class="nav-number">1.4.2.</span> <span class="nav-text">PROTOSTAR HEAP 3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MODERN-UNLINK"><span class="nav-number">1.4.3.</span> <span class="nav-text">MODERN UNLINK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CORRUPT-FREE-2"><span class="nav-number">1.4.4.</span> <span class="nav-text">CORRUPT FREE 2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PWNABLE-PROBLEM-STKOF"><span class="nav-number">1.4.5.</span> <span class="nav-text">PWNABLE PROBLEM STKOF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CORRUPT-FREE-2-1"><span class="nav-number">1.4.6.</span> <span class="nav-text">CORRUPT FREE 2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Always-keep-in-mind"><span class="nav-number">1.4.7.</span> <span class="nav-text">Always keep in mind</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POISINED-NULL-BYTE"><span class="nav-number">1.4.8.</span> <span class="nav-text">POISINED NULL BYTE</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View-Heap-as-an-Attacker-—-malloc"><span class="nav-number">1.5.</span> <span class="nav-text">View Heap as an Attacker — malloc()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CHEAT-MALLOC-1"><span class="nav-number">1.5.1.</span> <span class="nav-text">CHEAT MALLOC 1</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#begin-with-an-easy-example-–-fastbin"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">begin with an easy example – fastbin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#How-does-GLIBC-work-when-malloc-ing-a-fastbin"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">How does GLIBC work when malloc()ing a fastbin?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CHEAT-MALLOC-2"><span class="nav-number">1.5.2.</span> <span class="nav-text">CHEAT MALLOC 2</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Whether-malloc-with-normal-bins-and-double-linked-can-be-cheated"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">Whether malloc() with normal bins and double-linked can be cheated</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CHEAT-MALLOC-3"><span class="nav-number">1.5.3.</span> <span class="nav-text">CHEAT MALLOC 3</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View-Heap-as-an-Attacker-—-main-arena-predict-heap-chunk’s-location-despite-ASLR"><span class="nav-number">1.6.</span> <span class="nav-text">View Heap as an Attacker — main_arena / predict heap chunk’s location despite ASLR</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MAIN-ARENA"><span class="nav-number">1.6.1.</span> <span class="nav-text">MAIN_ARENA</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FAKE-MAIN-ARENA"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">FAKE MAIN_ARENA</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FIGHTING-WITH-ASSERTIONS"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">FIGHTING WITH ASSERTIONS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A-FAKE-ARENA-EXAMPLE"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">A FAKE ARENA EXAMPLE</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DEFEAT-ASLR"><span class="nav-number">1.6.2.</span> <span class="nav-text">DEFEAT ASLR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FURTHERMORE"><span class="nav-number">1.6.3.</span> <span class="nav-text">FURTHERMORE</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View-Heap-as-an-Attacker-–-mmap-and-munmap"><span class="nav-number">1.7.</span> <span class="nav-text">View Heap as an Attacker – mmap() and munmap()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OWN-THE-PAGE"><span class="nav-number">1.7.1.</span> <span class="nav-text">OWN THE PAGE</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RESOURCES"><span class="nav-number">1.8.</span> <span class="nav-text">RESOURCES</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#REFERENCE"><span class="nav-number">1.9.</span> <span class="nav-text">REFERENCE</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2017</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">F1r</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div> <span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div><div id="needsharebutton-float"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/three/three.min.js"></script><script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script><script id="dsq-count-scr" src="https://F1r-github-io.disqus.com/count.js" async></script><script type="text/javascript">var disqus_config=function(){this.page.url="http://blog.flier.net.cn/2017/10/21/PLAY-WITH-LINUX-HEAP-notes/",this.page.identifier="2017/10/21/PLAY-WITH-LINUX-HEAP-notes/",this.page.title="PLAY_WITH_LINUX_HEAP-notes"},d=document,s=d.createElement("script");s.src="https://F1r-github-io.disqus.com/embed.js",s.setAttribute("data-timestamp",""+ +new Date),(d.head||d.body).appendChild(s)</script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){var r=!1,s=0,a=0,i=n.title.trim(),c=i.toLowerCase(),l=n.content.trim().replace(/<[^>]+>/g,""),h=l.toLowerCase(),p=decodeURIComponent(n.url),u=[],f=[];if(""!=i&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}u=u.concat(e(t,c,!1)),f=f.concat(e(t,h,!1))}),(u.length>0||f.length>0)&&(r=!0,s=u.length+f.length)),r){[u,f].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});function d(e,o,n,r){for(var s=r[r.length-1],i=s.position,c=s.word,l=[],h=0;i+c.length<=n&&0!=r.length;){c===t&&h++,l.push({position:i,length:c.length});var p=i+c.length;for(r.pop();0!=r.length&&(s=r[r.length-1],i=s.position,c=s.word,p>i);)r.pop()}return a+=h,{hits:l,start:o,end:n,searchTextCount:h}}var g=[];0!=u.length&&g.push(d(0,0,i.length,u));for(var v=[];0!=f.length;){var $=f[f.length-1],C=$.position,m=$.word,x=C-20,w=C+80;x<0&&(x=0),w<C+m.length&&(w=C+m.length),w>l.length&&(w=l.length),v.push(d(0,x,w,f))}v.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var y=parseInt("1");y>=0&&(v=v.slice(0,y));function T(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var b="";b+=0!=g.length?"<li><a href='"+p+"' class='search-result-title'>"+T(i,g[0])+"</a>":"<li><a href='"+p+"' class='search-result-title'>"+i+"</a>",v.forEach(function(t){b+="<a href='"+p+'\'><p class="search-result">'+T(l,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:a,hitCount:s,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),!1===isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){27===t.which&&$(".search-popup").is(":visible")&&onPopupClose()})</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css"><script src="/lib/needsharebutton/needsharebutton.js"></script><script>pbOptions={},pbOptions.iconStyle="box",pbOptions.boxForm="horizontal",pbOptions.position="bottomCenter",pbOptions.networks="Weibo,Douban,QQZone,Twitter,Facebook",new needShareButton("#needsharebutton-postbottom",pbOptions),flOptions={},flOptions.iconStyle="box",flOptions.boxForm="horizontal",flOptions.position="middleRight",flOptions.networks="Weibo,Douban,QQZone,Twitter,Facebook",new needShareButton("#needsharebutton-float",flOptions)</script><script type="text/javascript" src="/live2d/script.js"></script><canvas id="live2dcanvas" width="200" height="400" class="live2d"></canvas><style>#live2dcanvas{position:fixed;right:0;z-index:999;pointer-events:none;bottom:-20px}</style><script>loadlive2d("live2dcanvas","/live2d/assets/miku/miku.model.json",.5)</script></body></html>